// Code generated by go-swagger; DO NOT EDIT.

package database_servers

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new database servers API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for database servers API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateDatabaseOnServer creates a database on an existing database server

Creates a new database on a database server. The database starts out empty. A new user with credentials separate from the database server's administrative user is also created, with full rights to the new database.
*/
func (a *Client) CreateDatabaseOnServer(params *CreateDatabaseOnServerParams, authInfo runtime.ClientAuthInfoWriter) (*CreateDatabaseOnServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDatabaseOnServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDatabaseOnServer",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/createDatabase",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDatabaseOnServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDatabaseOnServerOK), nil

}

/*
CreateDatabaseServer creates and registers a database server in a cloud provider

Creates a new database server. The database server starts out with only default databases.
*/
func (a *Client) CreateDatabaseServer(params *CreateDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) (*CreateDatabaseServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDatabaseServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDatabaseServer",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/managed",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDatabaseServerOK), nil

}

/*
DeleteDatabaseServerByCrn deregisters a database server by c r n

Deregisters a database server by its CRN.
*/
func (a *Client) DeleteDatabaseServerByCrn(params *DeleteDatabaseServerByCrnParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteDatabaseServerByCrnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDatabaseServerByCrnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteDatabaseServerByCrn",
		Method:             "DELETE",
		PathPattern:        "/v4/databaseservers/{crn}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDatabaseServerByCrnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDatabaseServerByCrnOK), nil

}

/*
DeleteDatabaseServerByName deregisters a database server by name

Deregisters a database server by its name.
*/
func (a *Client) DeleteDatabaseServerByName(params *DeleteDatabaseServerByNameParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteDatabaseServerByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDatabaseServerByNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteDatabaseServerByName",
		Method:             "DELETE",
		PathPattern:        "/v4/databaseservers/name/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDatabaseServerByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDatabaseServerByNameOK), nil

}

/*
DeleteMultipleDatabaseServersByCrn deregisters or terminate multiple database servers by c r n

Deregisters multiple databases servers, each by CRN.
*/
func (a *Client) DeleteMultipleDatabaseServersByCrn(params *DeleteMultipleDatabaseServersByCrnParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteMultipleDatabaseServersByCrnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMultipleDatabaseServersByCrnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteMultipleDatabaseServersByCrn",
		Method:             "DELETE",
		PathPattern:        "/v4/databaseservers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMultipleDatabaseServersByCrnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteMultipleDatabaseServersByCrnOK), nil

}

/*
GetDatabaseServerByCrn gets a database server by c r n

Gets information on a database server by its CRN.
*/
func (a *Client) GetDatabaseServerByCrn(params *GetDatabaseServerByCrnParams, authInfo runtime.ClientAuthInfoWriter) (*GetDatabaseServerByCrnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDatabaseServerByCrnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDatabaseServerByCrn",
		Method:             "GET",
		PathPattern:        "/v4/databaseservers/{crn}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDatabaseServerByCrnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDatabaseServerByCrnOK), nil

}

/*
GetDatabaseServerByName gets a database server by name

Gets information on a database server by its name.
*/
func (a *Client) GetDatabaseServerByName(params *GetDatabaseServerByNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetDatabaseServerByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDatabaseServerByNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDatabaseServerByName",
		Method:             "GET",
		PathPattern:        "/v4/databaseservers/name/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDatabaseServerByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDatabaseServerByNameOK), nil

}

/*
ListDatabaseServers lists database servers

Lists all database servers that are known, either because they were registered or because this service created them.
*/
func (a *Client) ListDatabaseServers(params *ListDatabaseServersParams, authInfo runtime.ClientAuthInfoWriter) (*ListDatabaseServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDatabaseServersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listDatabaseServers",
		Method:             "GET",
		PathPattern:        "/v4/databaseservers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListDatabaseServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListDatabaseServersOK), nil

}

/*
RegisterDatabaseServer registers a database server

Registers an existing database server.
*/
func (a *Client) RegisterDatabaseServer(params *RegisterDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) (*RegisterDatabaseServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRegisterDatabaseServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "registerDatabaseServer",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/register",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RegisterDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RegisterDatabaseServerOK), nil

}

/*
TerminateManagedDatabaseServer terminates a database server in a cloud provider and deregisters it

terminates a database server in a cloud provider and deregisters it
*/
func (a *Client) TerminateManagedDatabaseServer(params *TerminateManagedDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) (*TerminateManagedDatabaseServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTerminateManagedDatabaseServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "terminateManagedDatabaseServer",
		Method:             "DELETE",
		PathPattern:        "/v4/databaseservers/managed/{crn}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TerminateManagedDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TerminateManagedDatabaseServerOK), nil

}

/*
TestDatabaseServerConnection tests database server connectivity

Tests connectivity to a database. Use this to verify access to the database server from this service, and also to verify authentication credentials.
*/
func (a *Client) TestDatabaseServerConnection(params *TestDatabaseServerConnectionParams, authInfo runtime.ClientAuthInfoWriter) (*TestDatabaseServerConnectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestDatabaseServerConnectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testDatabaseServerConnection",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TestDatabaseServerConnectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TestDatabaseServerConnectionOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
