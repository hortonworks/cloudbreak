package com.sequenceiq.cloudbreak.shell.commands.common;

import static org.mockito.BDDMockito.given;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.sequenceiq.cloudbreak.api.model.SmartSenseSubscriptionJson;
import com.sequenceiq.cloudbreak.shell.model.ShellContext;

public class FlexSubscriptionCommandsTest {

    @InjectMocks
    private FlexSubscriptionCommands underTest;

    @Mock
    private ShellContext shellContext;

    @Mock
    private SmartSenseSubscriptionJson json;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        underTest = new FlexSubscriptionCommands(shellContext);
    }

    @Test
    public void subscriptionNotFound() {
        given(shellContext.getSmartSenseSubscription()).willReturn(null);

        boolean available = underTest.registerAvailable();

        Assert.assertFalse(available);
    }

    @Test
    public void subscriptionThrowsError() {
        given(shellContext.getSmartSenseSubscription()).willThrow(new RuntimeException());

        boolean available = underTest.registerAvailable();

        Assert.assertFalse(available);
    }

    @Test
    public void subscriptionAutoGenerated() {
        given(json.isAutoGenerated()).willReturn(true);
        given(shellContext.getSmartSenseSubscription()).willReturn(json);

        boolean available = underTest.registerAvailable();

        Assert.assertFalse(available);
    }

    @Test
    public void subscriptionNotAutoGenerated() {
        given(json.isAutoGenerated()).willReturn(false);
        given(shellContext.getSmartSenseSubscription()).willReturn(json);

        boolean available = underTest.registerAvailable();

        Assert.assertTrue(available);
    }
}
