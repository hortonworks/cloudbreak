syntax = "proto3";

package usermanagement;

option java_package = "com.cloudera.thunderhead.service.usermanagement";
option java_outer_classname = "UserManagementProto";
option go_package = "com/cloudera/cdp/protobuf";

import "version.proto";
import "paging.proto";
import "options.proto";
import "resources.proto";
import "nullable.proto";

// For future compatibility, all rpcs must take a request and return a response
// even if there is initially no content for these messages.
service UserManagement {
  // Handles an interactive login for a user from a Cloudera identity provider.
  // The user record will be created if necessary.
  // The account record must already exist.
  rpc InteractiveLogin (InteractiveLoginRequest)
    returns (InteractiveLoginResponse) {}

  // Handles an interactive login for a user in who is logging in using a
  // their own IdP. We assume that the account is created. The user will be
  // be created and their group membership synchronized with their Altus state.
  rpc InteractiveLogin3rdParty (InteractiveLogin3rdPartyRequest)
    returns (InteractiveLogin3rdPartyResponse) {}

  // Handles an interactive login for a user in who is logging in using the CDP control plane local
  // identity provider. We assume that the account had been created.
  rpc InteractiveLoginLocal (InteractiveLoginLocalRequest)
    returns (InteractiveLoginLocalResponse) {}

  // Deletes the account from Altus tests only.
  rpc DeleteAccount (DeleteAccountRequest)
    returns (DeleteAccountResponse) {}

  // Delete an actor from Altus.
  rpc DeleteActor (DeleteActorRequest)
    returns (DeleteActorResponse) {}

  // Delete trial user from Altus for tests only.
  rpc DeleteTrialUser (DeleteTrialUserRequest)
    returns (DeleteTrialUserResponse) {}

  // Gets all the information associated with an access key needed to verify a
  // request signature produced that key.
  rpc GetAccessKeyVerificationData (GetAccessKeyVerificationDataRequest)
    returns (GetAccessKeyVerificationDataResponse) {}

  // Verifies an interactive user session key. If the session key is expired an
  // exception is thrown. If the session key is found and is valid,
  // information about the user and their account is returned.
  rpc VerifyInteractiveUserSessionToken (VerifyInteractiveUserSessionTokenRequest)
    returns (VerifyInteractiveUserSessionTokenResponse) {}

  // Verifies an access token. If the access token is invalid (not found, expired, doesn't match),
  // an exception is thrown. If the access token is valid, information about the actor and their
  // account is returned.
  rpc VerifyAccessToken (VerifyAccessTokenRequest)
    returns (VerifyAccessTokenResponse) {}

  // Authenticate an actor. This method currently supports session tokens and
  // access key authentication.
  rpc Authenticate (AuthenticateRequest)
    returns (AuthenticateResponse) {}

  // Handles access key usage, marking the last time it was used and the last
  // service on which it was used.
  rpc AccessKeyUsage (AccessKeyUsageRequest)
    returns (AccessKeyUsageResponse) {}

  // Create user. Can only be used to create a user associated with a customer
  // identity provider connector.
  rpc CreateUser (CreateUserRequest)
    returns (CreateUserResponse) {}

  // Get user.
  rpc GetUser (GetUserRequest)
    returns (GetUserResponse) {}

  // List users.
  rpc ListUsers (ListUsersRequest)
    returns (ListUsersResponse) {}

  // Find users by Email.
  rpc FindUsersByEmail (FindUsersByEmailRequest)
    returns (FindUsersByEmailResponse) {}

  // Find users.
  rpc FindUsers (FindUsersRequest)
    returns (FindUsersResponse) {
  }

  // Creates a new access key.
  rpc CreateAccessKey (CreateAccessKeyRequest)
    returns (CreateAccessKeyResponse) {}

  // Updates an access key.
  rpc UpdateAccessKey (UpdateAccessKeyRequest)
    returns (UpdateAccessKeyResponse) {}

  // Deletes an access key.
  rpc DeleteAccessKey (DeleteAccessKeyRequest)
    returns (DeleteAccessKeyResponse) {}

  // Get access key.
  rpc GetAccessKey (GetAccessKeyRequest)
    returns (GetAccessKeyResponse) {}

  // List access keys.
  rpc ListAccessKeys (ListAccessKeysRequest)
    returns (ListAccessKeysResponse) {}

  // Creates a new access token.
  rpc CreateAccessToken (CreateAccessTokenRequest)
      returns (CreateAccessTokenResponse) {}

  // Deletes an access token.
  rpc DeleteAccessToken (DeleteAccessTokenRequest)
      returns (DeleteAccessTokenResponse) {}

  // Get an access token.
  rpc GetAccessToken (GetAccessTokenRequest)
      returns (GetAccessTokenResponse) {}

  // List access tokens.
  rpc ListAccessTokens (ListAccessTokensRequest)
      returns (ListAccessTokensResponse) {}

  // Creates a new SCIM access token.
  rpc CreateScimAccessToken (CreateScimAccessTokenRequest)
      returns (CreateScimAccessTokenResponse) {}

  // Deletes a SCIM access token.
  rpc DeleteScimAccessToken (DeleteScimAccessTokenRequest)
      returns (DeleteScimAccessTokenResponse) {}

  // List SCIM access tokens.
  rpc ListScimAccessTokens (ListScimAccessTokensRequest)
      returns (ListScimAccessTokensResponse) {}

  // Get the service version.
  rpc GetVersion (version.VersionRequest)
    returns (version.VersionResponse) {}

  // Get account.
  rpc GetAccount(GetAccountRequest)
    returns (GetAccountResponse) {}

  // Get account.
  rpc ListAccounts(ListAccountsRequest)
    returns (ListAccountsResponse) {}

  // Get the rights for an actor.
  rpc GetRights(GetRightsRequest)
    returns (GetRightsResponse) {}

  // Checks if an actor has the input rights on the input resources.
  rpc CheckRights(CheckRightsRequest)
    returns (CheckRightsResponse) {}

  // Create a regular account.
  rpc CreateAccount (CreateAccountRequest)
    returns (CreateAccountResponse) {}

  // Create a trial account.
  rpc CreateTrialAccount (CreateTrialAccountRequest)
    returns (CreateTrialAccountResponse) {}

  // Create an email based account.
  rpc CreateC1CAccount (CreateC1CAccountRequest)
    returns (CreateC1CAccountResponse) {}

  // An endpoint called when a user verifies their email by clicking the link we sent
  // them.
  rpc VerifyC1CEmail (VerifyC1CEmailRequest)
    returns (VerifyC1CEmailResponse) {}

  // Grant Entitlement to an Account
  rpc GrantEntitlement (GrantEntitlementRequest)
    returns (GrantEntitlementResponse) {}

  // Revoke Entitlement from an Account
  rpc RevokeEntitlement (RevokeEntitlementRequest)
    returns (RevokeEntitlementResponse) {}

  // Ensure default entitlements are granted to an Account
  rpc EnsureDefaultEntitlementsGranted (EnsureDefaultEntitlementsGrantedRequest)
    returns (EnsureDefaultEntitlementsGrantedResponse) {}

  // Assign a role to an assignee
  rpc AssignRole (AssignRoleRequest)
    returns (AssignRoleResponse) {}

  // Unassign a role from an assignee
  rpc UnassignRole (UnassignRoleRequest)
    returns (UnassignRoleResponse) {}

  // List the assigned roles for an assignee:
  rpc ListAssignedRoles (ListAssignedRolesRequest)
    returns (ListAssignedRolesResponse) {}

  // Assign a resource role to an assignee
  rpc AssignResourceRole (AssignResourceRoleRequest)
    returns (AssignResourceRoleResponse) {}

  // Unassign a resource role from an assignee
  rpc UnassignResourceRole (UnassignResourceRoleRequest)
    returns (UnassignResourceRoleResponse) {}

  // List the assigned resource roles for an assignee:
  rpc ListAssignedResourceRoles (ListAssignedResourceRolesRequest)
    returns (ListAssignedResourceRolesResponse) {}

  // List roles.
  rpc ListRoles (ListRolesRequest)
    returns (ListRolesResponse) {}

  // List resource roles.
  rpc ListResourceRoles (ListResourceRolesRequest)
    returns (ListResourceRolesResponse) {}

  // List resource assignees.
  rpc ListResourceAssignees (ListResourceAssigneesRequest)
    returns (ListResourceAssigneesResponse) {}

  // Update Cloudera Manager License Key
  rpc UpdateClouderaManagerLicenseKey (UpdateClouderaManagerLicenseKeyRequest)
    returns (UpdateClouderaManagerLicenseKeyResponse) {}

  // Initiates a support case creation pipeline.
  rpc InitiateSupportCase (InitiateSupportCaseRequest)
    returns (InitiateSupportCaseResponse) {}

  // Notify that a resource was deleted. All resource role assignments
  // associated with this resource will be deleted.
  rpc NotifyResourceDeleted (NotifyResourceDeletedRequest)
    returns (NotifyResourceDeletedResponse) {}

  // Create a machine user
  rpc CreateMachineUser (CreateMachineUserRequest)
    returns (CreateMachineUserResponse) {}

  // list machine users
  rpc ListMachineUsers (ListMachineUsersRequest)
    returns (ListMachineUsersResponse) {}

  // Delete a machine user
  rpc DeleteMachineUser (DeleteMachineUserRequest)
    returns (DeleteMachineUserResponse) {}

  rpc ListResourceRoleAssignments (ListResourceRoleAssignmentsRequest)
    returns (ListResourceRoleAssignmentsResponse) {}

  // Sets the account messages.
  rpc SetAccountMessages (SetAccountMessagesRequest)
    returns (SetAccountMessagesResponse) {}

  // Terms acceptance
  rpc AcceptTerms (AcceptTermsRequest)
    returns (AcceptTermsResponse) {}

  // Clearing accepted terms. This will clear the accepted terms with the
  // same version as the current Terms found in the TermsProvider.
  rpc ClearAcceptedTerms (ClearAcceptedTermsRequest)
    returns (ClearAcceptedTermsResponse) {}

  // Terms description
  rpc DescribeTerms (DescribeTermsRequest)
    returns (DescribeTermsResponse) {}

  // Terms listing
  rpc ListTerms (ListTermsRequest)
    returns (ListTermsResponse) {}

  // Entitlements listing
  rpc ListEntitlements (ListEntitlementsRequest)
    returns (ListEntitlementsResponse) {}

  // Set terms acceptance expiry
  rpc SetTermsAcceptanceExpiry (SetTermsAcceptanceExpiryRequest)
    returns (SetTermsAcceptanceExpiryResponse) {}

  // Confirm whether Altus account and Azure Subscription Id
  rpc ConfirmAzureSubscriptionVerified (ConfirmAzureSubscriptionVerifiedRequest)
    returns (ConfirmAzureSubscriptionVerifiedResponse) {}

  // Insert Azure Subscriptions
  rpc InsertAzureSubscription (InsertAzureSubscriptionInformationRequest)
    returns (InsertAzureSubscriptionInformationResponse) {}

  // Create group
  rpc CreateGroup (CreateGroupRequest)
    returns (CreateGroupResponse) {}

  // Delete group
  rpc DeleteGroup (DeleteGroupRequest)
    returns (DeleteGroupResponse) {}

  // Get groups
  rpc GetGroup (GetGroupRequest)
      returns (GetGroupResponse) {}

  // List groups
  rpc ListGroups (ListGroupsRequest)
    returns (ListGroupsResponse) {}

  // Update group
  rpc UpdateGroup (UpdateGroupRequest)
    returns (UpdateGroupResponse) {}

  // Add member to group
  rpc AddMemberToGroup (AddMemberToGroupRequest)
    returns (AddMemberToGroupResponse) {}

  // Remove member from group
  rpc RemoveMemberFromGroup (RemoveMemberFromGroupRequest)
    returns (RemoveMemberFromGroupResponse) {}

  // List group members
  rpc ListGroupMembers (ListGroupMembersRequest)
    returns (ListGroupMembersResponse) {}

  // List of groupCRNs corresponding to the member
  rpc ListGroupsForMember (ListGroupsForMemberRequest)
    returns (ListGroupsForMemberResponse) {}

  // List workload administration group names corresponding to the member
  rpc ListWorkloadAdministrationGroupsForMember (ListWorkloadAdministrationGroupsForMemberRequest)
    returns (ListWorkloadAdministrationGroupsForMemberResponse) {}

  // Creates a new cluster ssh private key.
  rpc CreateClusterSshPrivateKey (CreateClusterSshPrivateKeyRequest)
    returns (CreateClusterSshPrivateKeyResponse) {}

  // Get cluster ssh private key.
  rpc GetClusterSshPrivateKey (GetClusterSshPrivateKeyRequest)
    returns (GetClusterSshPrivateKeyResponse) {}

  // Get the authorization information about an assignee.
  rpc GetAssigneeAuthorizationInformation (GetAssigneeAuthorizationInformationRequest)
    returns (GetAssigneeAuthorizationInformationResponse) {}

  // Creates the identity provider connector
  rpc CreateIdentityProviderConnector (CreateIdentityProviderConnectorRequest)
    returns (CreateIdentityProviderConnectorResponse) {}

  // Lists identity provider connectors
  rpc ListIdentityProviderConnectors(ListIdentityProviderConnectorsRequest)
    returns (ListIdentityProviderConnectorsResponse) {}

  // Deletes identity provider connector
  rpc DeleteIdentityProviderConnector(DeleteIdentityProviderConnectorRequest)
    returns (DeleteIdentityProviderConnectorResponse) {}

  // Describes an identity provider connector
  rpc DescribeIdentityProviderConnector (DescribeIdentityProviderConnectorRequest)
    returns (DescribeIdentityProviderConnectorResponse) {}

  // Update an identity provider connector
  rpc UpdateIdentityProviderConnector (UpdateIdentityProviderConnectorRequest)
    returns (UpdateIdentityProviderConnectorResponse) {}

  // Set whether login using Cloudera SSO is enabled.
  rpc SetClouderaSSOLoginEnabled (SetClouderaSSOLoginEnabledRequest)
    returns (SetClouderaSSOLoginEnabledResponse) {}

  // Retrieves the control plane IdP metadata file for a workload
  // SSO service.
  rpc GetIdPMetadataForWorkloadSSO (GetIdPMetadataForWorkloadSSORequest)
    returns (GetIdPMetadataForWorkloadSSOResponse) {}

  // Process a workload SSO AuthNRequest. If the user is already authenticated
  // an appropriate authn response will be generated to the workload SSO. If not,
  // an appropriate authn request will be generated to either cloudera-sso or
  // to one of the customer defined identity providers.
  rpc ProcessWorkloadSSOAuthnReq(ProcessWorkloadSSOAuthnReqRequest)
    returns (ProcessWorkloadSSOAuthnReqResponse) {}

  // Generate a SSO AuthNRequest for control plane SP-initiated login.
  rpc GenerateControlPlaneSSOAuthnReq(GenerateControlPlaneSSOAuthnReqRequest)
    returns (GenerateControlPlaneSSOAuthnReqResponse) {}

  // Set the workload subdomain for an account if no such workload domain has
  // been set for a different account before.
  rpc SetWorkloadSubdomain(SetWorkloadSubdomainRequest)
    returns (SetWorkloadSubdomainResponse) {}

  // Create a machine-user, assign the resource roles and roles to it, create
  // an access key for it, and return it. This is exposed as a convenience method
  // for applications. Callers must be internal actors. The call is idempotent
  // and safe to be called multiple times. Machine users created through this
  // interface should be deleted by called DeleteWorkloadMachineUser.
  rpc CreateWorkloadMachineUser(CreateWorkloadMachineUserRequest)
    returns (CreateWorkloadMachineUserResponse) {}

  // Delete the workload machine user, all the role and resource role assignments,
  // as well as any access keys. This is a convenience method for application who
  // created a machine user using CreateWorkloadMachineUser.
  rpc DeleteWorkloadMachineUser(DeleteWorkloadMachineUserRequest)
    returns (DeleteWorkloadMachineUserResponse) {}

  // Returns the the workload administration group name for the
  // (account, right, resource) tuple. Will throw NOT_FOUND exception if no name
  // for the workload administration group has been set yet.
  rpc GetWorkloadAdministrationGroupName(GetWorkloadAdministrationGroupNameRequest)
    returns (GetWorkloadAdministrationGroupNameResponse) {}

  // Sets the workload administration group name for the (account, right, resource)
  // tuple. If the name was already set for the workload administration group
  // this is a no-op and the name generated for the workload administration group
  // will be returned.
  rpc SetWorkloadAdministrationGroupName(SetWorkloadAdministrationGroupNameRequest)
    returns (SetWorkloadAdministrationGroupNameResponse) {}

  // Deletes the workload administration group name for the (account, right, resource)
  // tuple. Throws a NOT_FOUND exception if no such workload administration group
  // can be found.
  rpc DeleteWorkloadAdministrationGroupName(DeleteWorkloadAdministrationGroupNameRequest)
    returns (DeleteWorkloadAdministrationGroupNameResponse) {}

  // Lists the workload administration groups in an account.
  rpc ListWorkloadAdministrationGroups(ListWorkloadAdministrationGroupsRequest)
    returns (ListWorkloadAdministrationGroupsResponse) {}

  // Sets the actor workloads credentials. This will replace and overwrite any
  // existing actor credentials.
  rpc SetActorWorkloadCredentials(SetActorWorkloadCredentialsRequest)
    returns (SetActorWorkloadCredentialsResponse) {}

  // Validates the actor workloads credentials based on the password policy for the account.
  rpc ValidateActorWorkloadCredentials(ValidateActorWorkloadCredentialsRequest)
    returns (ValidateActorWorkloadCredentialsResponse) {}

  // Retrieves the actor workload credentials.
  rpc GetActorWorkloadCredentials(GetActorWorkloadCredentialsRequest)
    returns (GetActorWorkloadCredentialsResponse) {}

  // Returns a unique ID for the following events:
  // * Role assignment events.
  // * Resource role assignment events.
  // * Group membership changes events.
  // * Actor deletion events.
  // * Actor workload credentials change events.
  // The IDs are guaranteed to be unique and can be used to track the above
  // changes in a specific account. If no such event has happened in the account
  // since tracking started an empty string will be returned instead of an ID.
  rpc GetEventGenerationIds(GetEventGenerationIdsRequest)
    returns (GetEventGenerationIdsResponse) {}

  // Adds an SSH public key for an actor.
  rpc AddActorSshPublicKey(AddActorSshPublicKeyRequest)
    returns (AddActorSshPublicKeyResponse) {}

  // Lists the SSH public keys for an actor.
  rpc ListActorSshPublicKeys(ListActorSshPublicKeysRequest)
    returns (ListActorSshPublicKeysResponse) {}

  // Describes an SSH public key.
  rpc DescribeActorSshPublicKey(DescribeActorSshPublicKeyRequest)
     returns (DescribeActorSshPublicKeyResponse) {}

  // Deletes an SSH public key for an actor.
  rpc DeleteActorSshPublicKey(DeleteActorSshPublicKeyRequest)
    returns (DeleteActorSshPublicKeyResponse) {}

  // Sets the workload password policy for an account.
  rpc SetWorkloadPasswordPolicy (SetWorkloadPasswordPolicyRequest)
    returns (SetWorkloadPasswordPolicyResponse) {}

  // Unsets the workload password policy for an account.
  rpc UnsetWorkloadPasswordPolicy (UnsetWorkloadPasswordPolicyRequest)
    returns (UnsetWorkloadPasswordPolicyResponse) {}

  // Sets the authentication policy for an account.
  rpc SetAuthenticationPolicy (SetAuthenticationPolicyRequest)
      returns (SetAuthenticationPolicyResponse) {}

  // Assign a cloud identity to an actor or group.
  rpc AssignCloudIdentity (AssignCloudIdentityRequest)
    returns (AssignCloudIdentityResponse) {}

  // Unassign a cloud identity from an actor or group.
  rpc UnassignCloudIdentity (UnassignCloudIdentityRequest)
    returns (UnassignCloudIdentityResponse) {}

  // Assign a cloud identity to a service principal.
  rpc AssignServicePrincipalCloudIdentity (AssignServicePrincipalCloudIdentityRequest)
    returns (AssignServicePrincipalCloudIdentityResponse) {}

  // Unassign a cloud identity from a service principal.
  rpc UnassignServicePrincipalCloudIdentity (UnassignServicePrincipalCloudIdentityRequest)
    returns (UnassignServicePrincipalCloudIdentityResponse) {}

  // List cloud identity mappings for service principals.
  rpc ListServicePrincipalCloudIdentities (ListServicePrincipalCloudIdentitiesRequest)
    returns (ListServicePrincipalCloudIdentitiesResponse) {}

  // Retrieves the CRN of the default identity provider connector used for CDP initiated logins.
  rpc GetDefaultIdentityProviderConnector (GetDefaultIdentityProviderConnectorRequest)
      returns (GetDefaultIdentityProviderConnectorResponse) {}

  // Sets the CRN of the default identity provider connector used for CDP initiated logins.
  rpc SetDefaultIdentityProviderConnector (SetDefaultIdentityProviderConnectorRequest)
      returns (SetDefaultIdentityProviderConnectorResponse) {}

  // Get user sync state model, including actors, groups, workload administration groups, etc
  rpc GetUserSyncStateModel (GetUserSyncStateModelRequest)
    returns (GetUserSyncStateModelResponse) {}

  // List all role assignments in an account.
  rpc ListRoleAssignments (ListRoleAssignmentsRequest)
      returns (ListRoleAssignmentsResponse) {}

  // Generate authentication token for workload API.
  rpc GenerateWorkloadAuthToken (GenerateWorkloadAuthTokenRequest)
    returns (GenerateWorkloadAuthTokenResponse) {}

  // Get authentication configuration for workload API.
  rpc GetWorkloadAuthConfiguration(GetWorkloadAuthConfigurationRequest)
    returns (GetWorkloadAuthConfigurationResponse) {}

  // Update user.
  rpc UpdateUser(UpdateUserRequest)
    returns (UpdateUserResponse) {}
}

// The state of the actor.
// This enumeration should not be visible to customer.
// Customer should only be able to see the user is active or not, a boolean value.
message ActorState {
  enum Value {
    // Active indicates that the actor can authenticate in to CDP.
    ACTIVE = 0;
    // Deleting indicates that the actor can no longer authenticate in to CDP.
    DELETING = 1;
    // Deactivated actor can no longer authenticate in to CDP.
    DEACTIVATED = 2;
  }
}

// An User is the Altus identity corresponding to an external SFDC contact. Users
// can interactively login, be assigned roles to, and can be designated account
// administrators.
message User {
  string externalUserId = 1;
  string userId = 2;
  string sfdcContactId = 3;
  string crn = 4;
  string email = 5;
  bool thunderheadAdmin = 6;
  // This may be an empty string.
  string firstName = 7;
  // This may be an empty string.
  string lastName = 8;
  // This field is deprecated and will be removed. Use creationDateMs instead.
  string creationDate = 9;
  // The creation date in ms from the Java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDateMs = 11;
  // This field is deprecated and will be removed. Use lastInteractiveLoginMs
  // instead.
  string lastInteractiveLogin = 10;
  // The last interactive login in ms from the Java epoch of 1970-01-01T00:00:00Z.
  // A value of zero means this is not set.
  uint64 lastInteractiveLoginMs = 12;
  // The identity provider ID the user belongs to. It can be one of the
  // following: (1) Cloudera default IdP (Okta) "Cloudera-Default", (2) Cloudera
  // Altus administration IdP "Cloudera-Administration", or (3) a customer
  // defined IdP and in this case this field will contain the CRN of the identity
  // provider.
  string identityProviderCrn = 13;
  // The username to use in all workload clusters for this user. This is
  // guaranteed to be unique in the account and stable over time, that is, the
  // same user is guaranteed to have the same workload username. Note though that
  // if a user is deleted the workload username it used becomes available to new
  // users in the account.
  string workloadUsername = 14;
  // The state of the user.
  ActorState.Value state = 15;
  // The date when the user record can safely be removed from storage.
  // In ms from the Java epoch of 1970-01-01T00:00:00Z.
  // The value is only meaningful when the 'state' is DELETING.
  uint64 safeDeleteDateMs = 16;
  // A list of cloud identities for the user.
  repeated CloudIdentity cloudIdentities = 17;
  // A user ID generated by the 3rd party IdP and passed as NameID in the SAML token, to uniquely
  // identify user. It also maps to the "userName" attribute of the SCIM User schema and passed as
  // "userName" while creating users through SCIM.
  string idpUserId = 18;
}

// A MachineUser is an internal Altus identity, used by applications to call
// api services. MachineUsers can be assigned roles and resource roles and can
// have access keys associated with them but they cannot interactively login or
// be designated account administrators.
message MachineUser {
  // The machine user's id.
  string machineUserId = 1;
  // The machine user's name.
  string machineUserName = 2;
  // The machine user's crn.
  string crn = 3;
  // The creation date in ms from the Java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDateMs = 4;
  // The username to use in all workload clusters for this machine user. This is
  // guaranteed to be unique in the account and stable over time, that is, the
  // same machine user is guaranteed to have the same workload username. Note
  // though that if the machine user is deleted the workload username it used
  // becomes available to new machine users in the account.
  string workloadUsername = 5;
  // Whether this is an internal machine user. Internal machine users are made
  // by platform services and not end-users. They are filtered out of account
  // level listing operations and cannot be modified by end-user operations.
  // Note that it is possible for end-users to list by name or CRN and otherwise
  // determine the existence of an internal machine user. We simply prevent them
  // from shooting themselves in the foot by modifying one.
  bool internal = 6;
  // The state of the machine user.
  ActorState.Value state = 7;
  // The date when the user record can safely be removed from storage.
  // In ms from the Java epoch of 1970-01-01T00:00:00Z.
  // The value is only meaningful when the 'state' is DELETING.
  uint64 safeDeleteDateMs = 8;
  // A list of cloud identities for the machine user.
  repeated CloudIdentity cloudIdentities = 9;
}

// A Group is a Altus resource that contains a collection of Actors. Groups
// can contain users and machine users and can be assigned roles and resource
// roles.
message Group {
  // Global unique Id generated by altus.
  string groupId = 1;
  // Name assigned to the group by the creator. Must be unique within the
  // account. Cannot be empty string.
  string groupName = 2;
  // The group crn.
  string crn = 3;
  // The creation date in ms from the Java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDate = 4;
  // Whether group membership is synced when a user logs in. This is only
  // relevant for federated users as we don't get group membership through
  // cloudera-sso.
  bool syncMembershipOnUserLogin = 5;
  // A list of cloud identities for the group.
  repeated CloudIdentity cloudIdentities = 6;
}

message AccessKeyUsage {
  // This field is deprecated and will be removed. Use timestampMs instead.
  string datetime = 1;
  // In ms from the Java epoch of 1970-01-01T00:00:00Z.
  uint64 timestampMs = 3;
  string service = 2;
}

message AccessKeyType {
  enum Value {
    UNSET = 0;
    // Private keys are encoded in PKCS#8
    // Public keys are encoded in X.509
    RSA = 1;
    // Private keys are 32 bytes encoded in base64 (44 bytes)
    // Public keys are 32 bytes
    ED25519 = 2;
  }
}

message AccessKey {
  enum Status {
    UNAVAILABLE = 0;
    ACTIVE = 1;
    INACTIVE = 2;
  }

  // This is deprecated. Use actorCrn instead.
  string externalUserId = 7;
  // This field is deprecated and will be removed. User actorCrn instead.
  string userId = 1;
  // This is the crn of the user or machine user
  string actorCrn = 9;
  string accessKeyId = 2;
  string crn = 3;
  Status status = 4;
  AccessKeyType.Value type = 10;
  // This field is deprecated and will be removed. Use creationDateMs instead.
  string creationDate = 5;
  // The creation date in ms from the Java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDateMs = 8;
  AccessKeyUsage lastUsage = 6;
  // Whether this is an internal access key. Internal access keys are made
  // by platform services and not end-users. They are filtered out of default
  // listing operations and cannot be modified by end-user operations. Note that
  // it is possible for end-users to list by ID or CRN and otherwise
  // determine the existence of an internal access key. We simply prevent them
  // from shooting themselves in the foot by modifying one.
  bool internal = 11;
}

message AccessToken {
  // The access token ID.
  string accessTokenId = 1;
  // The CRN of the user or machine user.
  string actorCrn = 2;
  // The access token CRN.
  string crn = 3;
  // The access token creation date in ms from the java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDate = 4;
  // The access token expiration date in ms from the java epoch of 1970-01-01T00:00:00Z.
  uint64 expirationDate = 5;
  // The scope of the access token.
  string scope = 6;
}

message AccessTokenHashAlgorithm {
  enum Value {
    // The access token secret is hashed using scrypt.
    SCRYPT = 0;
  }
}

// Object used to serialize access token metadata that does not require its own columns. We are
// putting most of the access token fields in here.
message AccessTokenDetailsStorage {
  // The access token secret, in hashed form.
  string accessTokenSecretHash = 1;
  // The algorithm used to hash the secret.
  AccessTokenHashAlgorithm.Value hashAlgorithm = 2;
  // The additional scope details for the access token.
  oneof scopeDetails {
    // The details if the access token scope is SCIM.
    ScimAccessTokenDetailsStorage scimDetails = 3;
  }
}

message ScimAccessTokenDetailsStorage {
  // The CRN of the identity provider connector which is associated with the access token.
  string identityProviderConnectorCrn = 1;
}

message ClusterSshPrivateKey {
  string accountId = 1;
  string clusterSshPrivateKeyId = 2;
  // This is the contents of a PEM file containing a PKCS#8 private key for SSHing to
  // clusters.
  string encryptedClusterSshPrivateKey = 3 [(options.FieldExtension.sensitive) = true];
  string awsAccountId = 4;
  string awsRegion = 5;
  // The creation date in ms from the Java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDateMs = 6;
}


// Note that this intentionally lacks a request context as this is called during
// the interactive login process.
message InteractiveLoginRequest {
  reserved 9;
  // The SFDC account id the user logging in belong to.
  string sfdcAccountId = 1;
  // Optional. The identity provider id the interactive login request is
  // associated with. If not given the default Cloudera identity provider ID
  // is assumed.
  string identityProviderId = 7;
  // Okta user Id. The Okta user ID is the unique, global, and never changing
  // id for a user. This is the ID used to lookup the user.
  string oktaUserId = 8;
  // SFDC contact ID. This uniquely identifies the user in SFDC but can change
  // over time (merging SFDC contacts, SFDC refreshes in stage/dev).
  string sfdcContactId = 2;
  // The user's email. This is a unique identifier but can change over time.
  // Cannot be null or empty but is not used to identify a user.
  string email = 3;
  // Whether or not the user is an account admin, or "owner". Users who are
  // flagged as thunderhead admins have all possible rights within the account.
  bool thunderheadAdmin = 4;
  // This may be an empty string.
  string firstName = 5;
  // This may be an empty string.
  string lastName = 6;
  // Optional. The InResponseTo field, which is included in the AuthnResponse by
  // the IdP during an SP-initiated login. For an IdP-initiated login this will
  // be an empty string.
  string inResponseTo = 10;
  // The IP address that the request was made from.
  string sourceIpAddress = 11;
}

// The message to verify if the given account has been verified with
// the azure subscription Id
message ConfirmAzureSubscriptionVerifiedRequest {
  string accountId = 1;
  string azureSubscriptionId = 2;
}

// Will throw an exception if the verification fails.
message ConfirmAzureSubscriptionVerifiedResponse {
}

// Used to insert the altus account Id and the azure subscription Id.
message InsertAzureSubscriptionInformationRequest {
  string accountId = 1;
  string azureSubscriptionId = 2;
}

// Will throw an exception if the insertion fails.
message InsertAzureSubscriptionInformationResponse {
}

message InteractiveLoginResponse {
  reserved 4, 5, 6;
  // The user's CRN.
  string crn = 1;
  // The console accee key ID.
  string accessKeyId = 2;
  // See AccessKeyKeyPairGenerator.AccessKeyPair.
  // Ed25519 private key is 32 bytes encoded in base64
  string privateKey = 3 [(options.FieldExtension.sensitive) = true];
  // A session token that can be used by consoles to authenticate users.
  string sessionToken = 7 [(options.FieldExtension.sensitive) = true];
  // Optional. A SAML AuthnResponse that should be sent to the to the workload
  // cluster. Will be empty if we are not forwarding the user to a workload
  // cluster.
  WorkloadSamlAuthnResponse workloadResponse = 8;
  // True if the InteractiveLoginRequest contained an InResponseTo that did not
  // exist in the cache (i.e. we got the request back after the cache TTL
  // expired). Will be false if we are not forwarding the user to a workload
  // cluster
  bool unknownInResponseTo = 9;
}

message InteractiveLogin3rdPartyRequest {
  // A user ID generated by the 3rd party IdP. The ID must be globally unique
  // and immutable over time.
  string idpUserId = 1;
  // The identity provider ID used for this login request.
  string identityProviderId = 2;
  // The user's email.
  string email = 3;
  // The groups the user belongs to. Empty group list will be treated as if no
  // group information was given to us. That is, the UMS will not perform any
  // group synchronization.
  repeated string group = 4;
  // This may be an empty string.
  string firstName = 5;
  // This may be an empty string.
  string lastName = 6;
  // Optional. The InResponseTo field, which is included in the AuthnResponse by
  // the IdP during an SP-initiated login. For an IdP-initiated or for non-SAML
  // logins this will be an empty string.
  string inResponseTo = 7;
  // The IP address that the request was made from.
  string sourceIpAddress = 8;
  // Optional. The Azure Object Id.
  string azureObjectId = 9;
}

message InteractiveLogin3rdPartyResponse {
  // The user's CRN.
  string crn = 1;
  // The console accee key ID.
  string accessKeyId = 2;
  // See AccessKeyKeyPairGenerator.AccessKeyPair.
  // Ed25519 private key is 32 bytes encoded in base64
  string privateKey = 3 [(options.FieldExtension.sensitive) = true];
  // A session token that can be used by consoles to authenticate users.
  string sessionToken = 4 [(options.FieldExtension.sensitive) = true];
  // Optional. A SAML AuthnResponse that should be sent to the to the workload
  // cluster. Will be empty if we are not forwarding the user to a workload
  // cluster.
  WorkloadSamlAuthnResponse workloadResponse = 5;
  // True if the InteractiveLogin3rdPartyRequest contained an InResponseTo that
  // did not exist in the cache (i.e. we got the request back after the cache
  // TTL expired). Will be false if we are not forwarding the user to a workload
  // cluster
  bool unknownInResponseTo = 6;
}

message InteractiveLoginLocalRequest {
  // The account ID the user is logging in to.
  string accountId = 1;
  // The user's username
  string username = 2;
  // The user's password
  string password = 3 [(options.FieldExtension.sensitive) = true];
  // Optional. The CDP CP authentication request ID, if any.
  string inResponseTo = 4;
  // The IP address that the request was made from.
  string sourceIpAddress = 5;
}

message InteractiveLoginLocalResponse {
  // The user's CRN.
  string crn = 1;
  // The console accee key ID.
  string accessKeyId = 2;
  // See AccessKeyKeyPairGenerator.AccessKeyPair.
  // Ed25519 private key is 32 bytes encoded in base64
  string privateKey = 3 [(options.FieldExtension.sensitive) = true];
  // A session token that can be used by consoles to authenticate users.
  string sessionToken = 4 [(options.FieldExtension.sensitive) = true];
  // Optional. A SAML AuthnResponse that should be sent to the to the workload
  // cluster. Will be empty if we are not forwarding the user to a workload
  // cluster.
  WorkloadSamlAuthnResponse workloadResponse = 5;
  // True if the InteractiveLoginLocalRequest contained an InResponseTo that
  // did not exist in the cache (i.e. we got the request back after the cache
  // TTL expired). Will be false if we are not forwarding the user to a workload
  // cluster
  bool unknownInResponseTo = 6;
}

// Note that this intentionally lacks a request context as this is called during
// the API authentication process.
message GetAccessKeyVerificationDataRequest {
  string accessKeyId = 1;
}

message GetAccessKeyVerificationDataResponse {
  string accessKeyId = 1;
  string externalAccountId = 2;
  string accountId = 3;
  // The type of altus account.
  AccountType accountType = 8;
  // Deprecated. Use actor CRN instead.
  string externalUserId = 4;
  // Deprecated. Use actor CRN instead.
  string userId = 5;
  // The actor CRN associated with the access key.
  string actorCrn = 7;
  AccessKeyType.Value type = 9;
  // See AccessKeyType for key format
  bytes publicKey = 6 [(options.FieldExtension.skipLogging) = true];
}

message VerifyInteractiveUserSessionTokenRequest {
  // The interactive user's session token.
  string sessionToken = 1 [(options.FieldExtension.sensitive) = true];
}

message VerifyInteractiveUserSessionTokenResponse {
  // The Altus account ID.
  string accountId = 1;
  // The Altus external account ID. This is going to go away at some point.
  string externalAccountId = 4;
  // The type of Altus account.
  AccountType accountType = 2;
  // The CRN of the user bearing the session token.
  string userCrn = 3;
}

message VerifyAccessTokenRequest {
  // The access token ID to authenticate.
  string accessTokenId = 1;
  // The access token plaintext secret to compare against what we have in storage.
  string accessTokenPlaintextSecret = 2 [(options.FieldExtension.sensitive) = true];
  // The scope to authenticate.
  string scope = 3;
}

message VerifyAccessTokenResponse {
  // The access token ID.
  string accessTokenId = 1;
  // The account ID.
  string accountId = 2;
  // The type of account.
  AccountType accountType = 3;
  // The CRN of the actor who owns the access token.
  string actorCrn = 4;
  // The external account ID. Needed for legacy behavior.
  string externalAccountId = 5;
}

// A request to authenticate a payload that was signed by using access key
// request signing V1 protocol.
message AccessKeyRequestSigningV1AuthRequest {
  // The authentication header as was received from the caller in the
  // x-altus-auth-header HTTP header.
  string authHeader = 1 [(options.FieldExtension.skipLogging) = true];
  // The message that was signed. For V1 this includes the HTTP method, content
  // type, date, and path of the request. See V1Authenticator for more details.
  string msgToVerify = 2 [(options.FieldExtension.skipLogging) = true];
}

// A request to authenticate a session token.
message SessionTokenAuthRequest {
  // The session token to authenticate.
  string sessionToken = 1 [(options.FieldExtension.sensitive) = true];
}

message AuthenticateRequest {
  oneof authenticationMethod {
    // Access key request signing V1 auth request.
    AccessKeyRequestSigningV1AuthRequest accessKeyV1AuthRequest = 1;
    // Session token auth request.
    SessionTokenAuthRequest sessionTokenAuthRequest = 2;
  }
}

message AuthenticateResponse {
  // The authenticated actor CRN.
  string actorCrn = 1;
}

message AccessKeyUsageRequest {
  string accessKeyId = 1;
  string service = 2;
}

message AccessKeyUsageResponse {
}

message CreateUserRequest {
  // The account ID for which the user is being added to.
  string accountId = 1;
  // The identity provider user id for the user. This ID must match the NameId
  // attribute value that will be passed for the user in the SAML response using
  // the associated IdP or the username attribute to use with the local authentication
  // provider. It also maps to the "userName" attribute of the SCIM User schema.
  string idpUserId = 2;
  // The identity provider name or CRN the user belongs to. To create a local user in an
  // account pass the CDP_LOCAL_IDENTITY_PROVIDER_CRN.
  string identityProviderNameOrCrn = 3;
  // The user's email.
  string email = 4;
  // The groups the user belongs to. May be empty.
  repeated string group = 5;
  // This may be an empty string.
  string firstName = 6;
  // This may be an empty string.
  string lastName = 7;
  // Whether or not the user is an account admin. Users who are
  // flagged as account admins have all rights within the account.
  bool accountAdmin = 8;
  // Whether to enable or disable the user.
  bool isDeactivated = 9;
}

message CreateUserResponse {
  User user = 1;
}

message GetUserRequest {
  reserved 1;
  string accountId = 2;
  string userIdOrCrn = 3;
}

message GetUserResponse {
  User user = 1;
}

message ListUsersRequest {
  reserved 1;
  // The account in which to list users.
  string accountId = 4;
  // The list is optional. The default is to return all users.
  repeated string userIdOrCrn = 5;
  // Whether to include deleted users.
  bool includeDeleted = 6;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message ListUsersResponse {
  repeated User user = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message DeleteActorRequest {
  // Actor Crn to be deleted. Deprecated, use Actor instead.
  string actorCrn = 1;
  // The actor to delete.
  Actor actor = 2;
  // If set the 'true' the actor will be deleted from storage.
  bool forceDelete = 3;
}

message DeleteActorResponse {
  // A list of all the access key CRNs that were deleted for the actor
  repeated string accessKeysDeleted = 1;
  // A list of all the access token CRNs that were deleted for the actor.
  repeated string accessTokensDeleted = 7;
  // A list of all group CRNs from which the user were removed.
  repeated string groupsModified = 2;
  // A list of all the roles CRNs that the users were unassigned from.
  repeated string rolesUnassigned = 3;
  // A list of all resource assignments that were removed. Includes the
  // resource role CRNs and the resource that were assigned.
  repeated ResourceAssignment resourceRolesUnassigned = 4;
  // The Crn of the deleted actor.
  string actorCrn = 5;
  // The workload username of the deleted actor.
  string workloadUsername = 6;
}

message DeleteTrialUserRequest {
  // User Crn to be deleted.
  string userCrn = 1;
}

message DeleteTrialUserResponse {
}

message FindUsersByEmailRequest {
  // Find users based on email address. It will find users across accounts.
  string email = 1;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message FindUsersByEmailResponse {
  // The users.
  repeated User user = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message SearchByEmail {
  string email = 1;
}

message SearchByWorkloadUsername {
  string workloadUsername = 1;
}

message FindUsersRequest {
  oneof search_by {
    SearchByEmail searchByEmail = 1;
    SearchByWorkloadUsername searchByWorkloadUsername = 2;
  }
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message FindUsersResponse {
  // The users.
  repeated User user = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message CreateAccessKeyRequest {
  // The account id to which the user or machine user belongs to.
  string accountId = 2;
  // A union containing an actor identifier.
  oneof actor {
    // The machine user name or CRN.
    string machineUserNameOrCrn = 3;
    // The user id or CRN.
    string userIdOrCrn = 4;
  }
  // The type of access key to create
  AccessKeyType.Value type = 5;
  // Whether this should be an internal access key. Internal access keys are made
  // by platform services and not end-users. They are filtered out of default
  // listing operations and cannot be modified by end-user operations. Note that
  // it is possible for end-users to list by ID or CRN and otherwise
  // determine the existence of an internal access key.
  bool internal = 11;
}

message CreateAccessKeyResponse {
  AccessKey accessKey = 1;
  // See AccessKeyType for key format
  string privateKey = 2 [(options.FieldExtension.sensitive) = true];
}

message UpdateAccessKeyRequest {
  reserved 1;
  string accountId = 3;
  string accessKeyIdOrCrn = 4;
  // The CRN of the actor requesting to update the key.
  AccessKey.Status status = 2;
}

message UpdateAccessKeyResponse {
  AccessKey accessKey = 1;
}

message DeleteAccessKeyRequest {
  reserved 1;
  string accountId = 2;
  string accessKeyIdOrCrn = 3;
}

message DeleteAccessKeyResponse {
}

message GetAccessKeyRequest {
  reserved 1;
  string accountId = 2;
  string accessKeyIdOrCrn = 3;
}

message GetAccessKeyResponse {
  AccessKey accessKey = 1;
}

message ListAccessKeysRequest {
  reserved 1;
  string accountId = 4;
  repeated string accessKeyIdOrCrn = 5;
  // This optionally filters the request to the given actor, a user or a
  // machine user.
  Actor keyAssignee = 6;
  // Whether to include internal access keys. Note that this has no impact when
  // listing by ID or CRN. For those calls, internal access keys are always
  // returned.
  bool includeInternal = 7;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message ListAccessKeysResponse {
  repeated AccessKey accessKey = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message CreateAccessTokenRequest {
  // The actor to which the access token is being assigned to.
  Actor actor = 1;
  // The access token expiry date in ms from the java epoch of 1970-01-01T00:00:00Z.
  uint64 expirationDate = 2;
}

message CreateAccessTokenResponse {
  // The access token.
  AccessToken accessToken = 1;
  // The access token plaintext secret.
  string plaintextSecret = 2 [(options.FieldExtension.sensitive) = true];
}

message DeleteAccessTokenRequest {
  // The account Id for which the request is being made.
  string accountId = 1;
  // The Id or CRN of the access token being deleted.
  string accessTokenIdOrCrn = 2;
}

message DeleteAccessTokenResponse {
}

message GetAccessTokenRequest {
  // The account id to which the access token belongs to.
  string accountId = 1;
  // The access token ID or CRN.
  string accessTokenIdOrCrn = 2;
}

message GetAccessTokenResponse {
  // The access token.
  AccessToken accessToken = 1;
}

message ListAccessTokensRequest {
  // The account id to which the access token(s) belongs to.
  string accountId = 1;
  // The list of access token ID or CRNs.
  repeated string accessTokenIdOrCrn = 2;
  // This optionally filters the request to the given actor, a user or a machine user.
  Actor tokenAssignee = 3;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 4;
  paging.PageToken pageToken = 5;
}

message ListAccessTokensResponse {
  // The list of access tokens.
  repeated AccessToken accessToken = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message CreateScimAccessTokenRequest {
  // The account Id for the IDP to create SCIM access token.
  string accountId = 1;
  // The IdP connector to create SCIM access token.
  string identityProviderConnectorNameOrCrn = 2;
  // The access token expiry date in ms from the java epoch of 1970-01-01T00:00:00Z.
  uint64 expirationDate = 3;
}

message CreateScimAccessTokenResponse {
  // The access token.
  AccessToken accessToken = 1;
  // The access token plaintext secret.
  string plaintextSecret = 2 [(options.FieldExtension.sensitive) = true];
}

message DeleteScimAccessTokenRequest {
  // The account Id for which the request is being made.
  string accountId = 1;
  // The Id or CRN of the access token being deleted.
  string accessTokenIdOrCrn = 2;
}

message DeleteScimAccessTokenResponse {
}

message ListScimAccessTokensRequest {
  // The account id to which the access token(s) belongs to.
  string accountId = 1;
  // The IdP connector which the access token(s) belongs to.
  string identityProviderConnectorNameOrCrn = 2;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListScimAccessTokensResponse {
  // The list of access tokens.
  repeated AccessToken accessToken = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

// Request object to create a new cluster SSH private key.
message CreateClusterSshPrivateKeyRequest {
  // The Altus account ID
  string accountId = 1;
  // The AWS account ID
  string awsAccountId = 2;
  // AWS region
  string awsRegion = 3;
  // Encrypted cluster SSH private key
  string encryptedClusterSshPrivateKey = 4 [(options.FieldExtension.sensitive) = true];
}

// Response object for creating a new cluster SSH private key.
message CreateClusterSshPrivateKeyResponse {
  // The ClusterSshPrivateKey object
  ClusterSshPrivateKey clusterSshPrivateKey= 1;
}

// Request object to retrieve cluster ssh private key for a given set of parameters.
message GetClusterSshPrivateKeyRequest {
  // The Altus account ID
  string accountId = 1;
  // The AWS account ID
  string awsAccountId = 2;
  // AWS region
  string awsRegion = 3;
}

// Response object that contains cluster SSH private key details.
message GetClusterSshPrivateKeyResponse {
  // The ClusterSshPrivateKey object
  ClusterSshPrivateKey clusterSshPrivateKey = 1 [(options.FieldExtension.sensitive) = true];
}

// EntitlementGrant lists name of entitlement associated with account.
// This object is used in GRPC to communicate to/from UMS, i.e. is stashed
// into the Account record.
message EntitlementGrant {
  // Entitlement name
  string entitlementName = 1;
  // Date Entitlement is granted.
  uint64 grantDateMs = 2;
  // Crn of grantor
  string actorGrantorCrn = 3;
}

// A wrapper around the message string.
message AccountMessage {
  // the message
  string message = 1;
}

// Contains account-wide user configurable messages
message AccountMessages {
  // A message the user sees when they don't have sufficient rights to perform
  // an operation.
  AccountMessage contactYourAdministrator = 1;
}

enum AccountType {
  // Regular accounts have an SFDC account id associated with them and are
  // multi-tenant
  REGULAR = 0;
  // Trial accounts are single-user accounts that do not necessarily have
  // SFDC account id associated with them
  TRIAL = 1;
  // C1C accounts. C1C accounts are created by users using in email
  C1C = 2;
}

message Account {
  // The external account id. The id uniquely identifies the account within
  // Altus.
  string externalAccountId = 1;
  // The SFDC account id associated with the account. Note that there may be
  // more than one Altus account associated with an SFDC account.
  string sfdcAccountId = 8;
  // The identity provider id. This is generated by Altus to uniquely identify
  // the specific identity provider used to authenticate users in the account.
  // All Altus accounts always support the default Cloudera identity provider
  // (Okta Altus Application).
  string identifyProviderId = 9;
  string accountId = 2;
  // This field is deprecated and will be removed. Use creationDateMs instead.
  string creationDate = 3;
  // The creation date in ms from the Java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDateMs = 7;
  // May be empty string
  string clouderaManagerLicenseKey = 4 [(options.FieldExtension.skipLogging) = true];
  string externalIdForAWSDelegatedAccess = 5;
  // Contains account-wide user configurable messages
  AccountMessages accountMessages = 10;
  // List of entitlements associated with account.
  // These entitlements supersede the legacy entitlements
  repeated Entitlement entitlements = 11;
  // Account type can be regular or trial. By default it is regular account
  AccountType accountType = 12;
  // Whether login using Cloudera SSO is enabled
  bool clouderaSSOLoginEnabled = 13;
  // The workload subdomain for the account. This is used as part of the domain
  // name for all workload clusters for the account in a specific environment.
  // Specifically, the domain for a workload should look something like:
  // <environment-identifier>.<workload-sub-domain>.cloudera.site
  // Note that this is ensured to be unique, that is, there will not be two
  // accounts with the same workload sub domain.
  string workloadSubdomain = 14;
  // The global workload password policy.
  WorkloadPasswordPolicy globalPasswordPolicy = 15;
  // The workload password policy for machine users.
  WorkloadPasswordPolicy machineUserPasswordPolicy = 16;
  // The authentication policy.
  AuthenticationPolicy authenticationPolicy = 17;
}

message AuthenticationPolicy {
  // The inactivity duration, in seconds, of the access key, which would invalidate
  // the access key due to no activity.
  // Set the value to '0' to use system default inactivity duration.
  // There's no access key invalidation from no activity if the value is greater or equal to expiration.
  int32 accessKeyInactivityDurationSec = 1;
  // The expiration, in seconds, of the access key.
  // Set the value to '0' to use system default expiration.
  int32 accessKeyExpirationSec = 2;
  // The inactivity duration, in seconds, of the UI session token, which would
  // invalidate the session token due to no activity.
  // Set the value to '0' to use system default inactivity duration.
  // There's no session token invalidation from no activity if the value is greater or equal to expiration.
  int32 sessionTokenInactivityDurationSec = 3;
  // The expiration, in seconds, of the UI session token.
  // Set the value to '0' to use system default expiration.
  int32 sessionTokenExpirationSec = 4;
  // The expiration, in seconds, of the workload auth token.
  // Set the value to '0' to use system default expiration.
  int32 workloadAuthTokenExpirationSec = 5;
}

// Either the accountId or externalAccountId is required to get
// the Account details
message GetAccountRequest {
  // The external account id. The id uniquely identifies the account within
  // Altus.
  string externalAccountId = 1;
  string accountId = 2;
}

message GetAccountResponse {
  Account account = 1;
}

// Request object for a list accounts request.
message ListAccountsRequest {
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 1;
  paging.PageToken pageToken = 2;
}

message ListAccountsResponse {
  repeated Account account = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message DeleteAccountRequest {
  // Account Id identifies the account.
  string accountId = 1;
}

message DeleteAccountResponse {
}

message GetRightsRequest {
  string actorCrn = 1;
  // To collect rights relevant to a specific resource specify the
  // resource CRN. To collect rights relevant to resource independent
  // service rights pass '*' (Resource.WILDCARD).
  string resourceCrn = 2;
}

message PolicyStatement {
  repeated string right = 1;
  repeated string resource = 2;
}

message PolicyDefinition {
  repeated PolicyStatement statement = 1;
}

message Policy {
  string crn = 1;
  PolicyDefinition policyDefinition = 2;
  uint64 creationDateMs = 3;
}

message Role {
  string crn = 1;
  uint64 creationDateMs = 2;
  repeated Policy policy = 3;
  string requiredEntitlement = 4;
}

message ResourceRole {
  string crn = 1;
  uint64 creationDateMs = 2;
  repeated string right = 3;
  string requiredEntitlement = 4;
}

message ResourceRoleAssignment {
  ResourceRole resourceRole = 1;
  repeated string resource = 2;
}

message RoleAssignment {
  Role role = 1;
}

message ResourceRoleAssignmentRecord {
  // AssigneeCrn of the user who assigned resource role to resource role crn
  string assigneeCrn = 1;
  // ResourceCrn is crn/name of the resource which is assigned to resource role crn
  string resourceCrn = 2;
  // resource role crn is resource role crn name to which resource crn is assigned.
  string resourceRoleCrn = 3;
}

message ResourceAssignment {
  string resourceCrn = 1;
  string resourceRoleCrn = 2;
}

message ResourceAssignee {
  string assigneeCrn = 1;
  string resourceRoleCrn = 2;
}

message GetRightsResponse {
  reserved 5;
  // A list of resource role assignments.
  repeated ResourceRoleAssignment resourceRolesAssignment = 1;
  // A list of RoleAssignments.
  repeated RoleAssignment roleAssignment = 2;
  // Whether the actor is a thunderhead admin or not.
  bool thunderheadAdmin = 3;
  // A list of group CRNs the actor is a member of. Deprecated and will be removed.
  // CDPCP-2584 tracks removing it.
  repeated string groupCrn = 4;
}

message RightsCheck {
  string resourceCrn = 1;
  repeated string right = 2;
}

message CheckRightsRequest {
  string actorCrn = 1;
  repeated RightsCheck check = 2;
}

message CheckRightsResponse {
  repeated bool result = 1;
}

message CreateAccountRequest {
  // The external account ID for the account. This must be an SFDC account ID.
  string externalAccountId = 1;
  // A base64 encoded Cloudera Manager license to use for the account.
  string clouderaManagerLicenseKey = 2 [(options.FieldExtension.skipLogging) = true];
  // The identity provider associated with the account. If none is passed, the
  // default cloudera identity provider will be used.
  string identityProviderId = 3;
}

message CreateAccountResponse {
  Account account = 1;
}

message CreateTrialAccountRequest {
  // The okta user ID of the user for which we are creating a trial account.
  string oktaUserId = 1;
}

message CreateTrialAccountResponse {
  Account account = 1;
}

message CreateC1CAccountRequest {
  // The email of the user creating the account. An email can be used to create one
  // and only one account.
  string email = 1;
  // This may be an empty string.
  string firstName = 2;
  // This may be an empty string.
  string lastName = 3;
  // The user's password;
  string password = 4 [(options.FieldExtension.sensitive) = true];
}

message CreateC1CAccountResponse {
  Account account = 1;
}

message VerifyC1CEmailRequest {
  // The registration token passed by the caller
  string registrationToken = 1 [(options.FieldExtension.sensitive) = true];
}

message VerifyC1CEmailResponse {
  string userCrn = 1;
}

message AccountId {
  // A union containing an external account id or thunderhead account id.
  oneof account_oneof {
    // External AccountId for which entitlement is granted.
    string externalAccountId = 1;
    // Thunderhead Account Id.
    string accountId = 2;
  }
}

message GrantEntitlementRequest {
  // SFDC AccountId for which entitlement is granted.
  // Deprecated. Use AccountId instead.
  string sfdcAccountId = 1;
  // Entitlement to add to an account.
  string entitlementName = 2;
  // A union containing an external account id or thunderhead account id.
  AccountId accountId = 3;
}

message GrantEntitlementResponse {
  // Account details
  Account account = 1;
}

message RevokeEntitlementRequest {
  // SFDC AccountId for which entitlement is revoked.
  // Deprecated. Use AccountId instead.
  string sfdcAccountId = 1;
  // Entitlement name which is revoked.
  string entitlementName = 2;
  // A union containing an sfdc account id or thunderhead account id.
  AccountId accountId = 3;
}

message RevokeEntitlementResponse {
  // Account Details
  Account account = 1;
}

message EnsureDefaultEntitlementsGrantedRequest {
  // A union containing an sfdc account id or thunderhead account id.
  AccountId accountId = 1;
}

message EnsureDefaultEntitlementsGrantedResponse {
  // Account Details
  Account account = 1;
}

// A union containing an actor identifier, a user or a machine-user.
message Actor {
  // The account the actor belongs to.
  string accountId = 1;
  oneof actor_oneof {
    // The machine user name or CRN.
    string machineUserNameOrCrn = 2;
    // The user id or CRN.
    string userIdOrCrn = 3;
  }
}

// A union containing an assignee identifier, a user or a machine-user or a group.
message Assignee {
  // The account the assignee belongs to.
  string accountId = 1;
  oneof assignee_oneof {
    // The machine user name or CRN.
    string machineUserNameOrCrn = 2;
    // The user id or CRN.
    string userIdOrCrn = 3;
    // The group name or CRN.
    string groupNameOrCrn = 4;
  }
}

message AssignRoleRequest {
  // This is a deprecated assignee object and will be removed shortly.
  // Please use Assignee instead.
  Actor actor = 4;
  Assignee assignee = 5;
  string roleNameOrCrn = 3;
}

message AssignRoleResponse {
  string assigneeCrn = 1;
}

message UnassignRoleRequest {
  // This is a deprecated assignee object and will be removed shortly.
  // Please use Assignee instead.
  Actor actor = 4;
  Assignee assignee = 5;
  string roleNameOrCrn = 3;
}

message UnassignRoleResponse {
  string assigneeCrn = 1;
}

message ListAssignedRolesRequest {
  // This is a deprecated assignee object and will be removed shortly.
  // Please use Assignee instead.
  Actor actor = 5;
  Assignee assignee = 6;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListAssignedRolesResponse {
  repeated string roleCrn = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message AssignResourceRoleRequest {
  // This is a deprecated assignee object and will be removed shortly.
  // Please use Assignee instead.
  Actor actor = 5;
  Assignee assignee = 6;
  string resourceCrn = 3;
  string resourceRoleCrn = 4;
}

message AssignResourceRoleResponse {
  string assigneeCrn = 1;
}

message UnassignResourceRoleRequest {
  // This is a deprecated assignee object and will be removed shortly.
  // Please use Assignee instead.
  Actor actor = 5;
  Assignee assignee = 6;
  string resourceCrn = 3;
  string resourceRoleCrn = 4;
}

message UnassignResourceRoleResponse {
  string assigneeCrn = 1;
}

message ListAssignedResourceRolesRequest {
  // This is a deprecated assignee object and will be removed shortly.
  // Please use Assignee instead.
  Actor actor = 5;
  Assignee assignee = 6;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListAssignedResourceRolesResponse {
  repeated ResourceAssignment resourceAssignment = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message ListRolesRequest {
  // The account in which to list the roles.
  string accountId = 1;
  // The list is optional. The default is to return all roles.
  repeated string roleNameOrCrn = 2;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListRolesResponse {
  repeated Role role = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message ListResourceRoleAssignmentsRequest {
  // Account for which to list the resource role assignments
  string accountId = 1;
  // The resourceRoleNameOrCrn is optional. It is name of resourceRoleCrn
  // Default is to list all the resource role assignments.
  string resourceRoleNameOrCrn = 2;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListResourceRoleAssignmentsResponse {
  // Array of resourceRoleAssignmentRecord.
  repeated ResourceRoleAssignmentRecord resourceRoleAssignmentRecord = 1;
    // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message ListResourceRolesRequest {
  // The account in which to list the roles.
  string accountId = 1;
  // The list is optional. The default is to return all resource roles.
  repeated string resourceRoleCrn = 2;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListResourceRolesResponse {
  repeated ResourceRole resourceRole = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message ListResourceAssigneesRequest {
  string accountId = 1;
  string resourceCrn = 2;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListResourceAssigneesResponse {
  repeated ResourceAssignee resourceAssignee = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message UpdateClouderaManagerLicenseKeyRequest {
  string externalAccountId = 1;
  string clouderaManagerLicenseKey = 2;
}

message UpdateClouderaManagerLicenseKeyResponse {
  Account account = 1;
}

message NotifyResourceDeletedRequest {
  string resourceCrn = 1;
}

message NotifyResourceDeletedResponse {
}

// This structure is used to serialize the redis access key entry and not
// used in our rpc system.
message RedisAccessKeyCacheEntry {
  // Deprecated. Use actorCrn instead.
  string externalUserId = 6;
  // Deprecated. Use actorCrn instead.
  string userId = 1;
  string actorCrn = 9;
  string externalAccountId = 7;
  string accountId = 2;
  // The type of altus account.
  AccountType accountType = 10;
  AccessKeyType.Value accessKeyType = 11;
  bytes publicKey = 3 [(options.FieldExtension.skipLogging) = true];
  int64 lastAccessed = 4;
  int32 inactivityDurationSec = 5;
  // Marks the entry as a "do not use" entry. Used by the UMS to prevent
  // creation of bad cache entries. See UserManagementService.java for
  // more details.
  bool doNotUseAccessKey = 8;
}

// This structure is used to serialize the redis actor tombstone entry and not
// used in our rpc system.
message RedisActorTombstoneCacheEntry {
  // Redis does not allow null values, so in order to serialize a tombstone we
  // have to some member that we set to a non default value. Let's use a bool
  // for that. This is always set to 'true' and the actual value is ignored.
  bool created = 1;
}

// A structure that contains information about SSO session that was initiated
// by a workload cluster SP.
message SSOForWorkloadClusterDetails {
  // The account ID for which this SSO request is for.
  string accountId = 1;
  // The workload cluster service provider (SP) AuthnRequest ID.
  string workloadClusterAuthnRequestId = 2;
  // The workload cluster assertion consumer service (ACS) URL.
  string workloadClusterAcs = 3;
  // The workload cluster assertion consumer service protocol binding to use.
  string workloadClusterAcsProtocolBinding = 4;
  // The relay state passed to us as part of the workload cluster service
  // provider (SP) AuthnRequest.
  string workloadClusterRelayState = 5;
}

// This structure is used to serialize the redis cache entry for workload
// clusters authn requests while waiting for the user to login using the idp
// for the account. It contains information that is needed to complete the
// AuthResponse to the workload cluster SP.
message RedisSSOCacheEntry {
  // The AuthnRequest ID of the control plane AuthnRequest to the IdP the user
  // needs to authenticate with. It is used as the key of the cache entry as
  // this is what we get back from the IdP in the InResponseTo field.
  string controlPlaneAuthnRequestId = 1;
  oneof ssoDetails {
    // Covers SAML provider attributes.
    SSOForWorkloadClusterDetails forWorkloadClusters = 2;
  }
}

message SessionTokenVerificationAlgorithm {
  enum Value {
    UNSET = 0;
    // The public key is a x.509 encoded key (65 bytes). Use jose4j
    // ECDSA_USING_P256_CURVE_AND_SHA256 algorithm to verify the session token.
    ECDSA_USING_P256_CURVE_AND_SHA256 = 1;
  }
}

// This structure is used to serialize the redis session token entry and is not
// used in our rpc system. Session tokens are generated for interactive login
// sessions - that is for users.
message RedisSessionTokenCacheEntry {
  // The user's CRN
  string userCrn = 1;
  // The user's external account ID. This is going to go away at some point.
  string externalAccountId = 7;
  // The type of the Altus account.
  AccountType accountType = 2;
  // The verification algorithm to use.
  SessionTokenVerificationAlgorithm.Value verificationAlgo = 3;
  // The public key to use to verify the session token.
  bytes publicKey = 4 [(options.FieldExtension.skipLogging) = true];
  int64 lastAccessed = 5;
  int32 inactivityDurationSec = 6;
}

// This is used to serialize all the Role dynamoDB related information that is
// not indexed.
message RoleDetails {
  repeated string policyCrns = 1;
}

message InitiateSupportCaseRequest {
  string accountId = 5;
  // The CRN of the user initiating the support case.
  string submitterCrn = 6;
  string component = 1;
  string subComponent = 2;
  string resourceCrn = 3;
  string clientData = 4;
}

message InitiateSupportCaseResponse {
  string caseFormUrl = 1;
}

message CreateMachineUserRequest {
  // The account id in which to create the machine user. This is deprecated and
  // will be removed shortly. Use account ID instead.
  resources.Id accountResourceId = 1;
  // The machine user name. Must be unique within the account.
  string machineUserName = 2;
  // The account id the machine user belongs to.
  string accountId = 3;
}

message CreateMachineUserResponse {
  MachineUser machineUser = 1;
}

message ListMachineUsersRequest {
  // The account id the machine user belongs to.
  string accountId = 1;
  // A list of MachineUsers name or CRN to retrieve. The list is optional if
  // not provided all MachineUsers in the account will be returned.
  repeated string machineUserNameOrCrn = 2;
  // Whether to include internal machine users. Note that this has no impact
  // when listing by name or CRN. For those calls, internal machine users are
  // always returned.
  bool includeInternal = 5;
  // Whether to include deleted machine users.
  bool includeDeleted = 6;
  // Whether to include workload machine users. All regular machine users are
  // workload machine users. This is a subset of the internal machine users,
  // which have a password set. This field has no effect if internal machine
  // users are requested (`includeInternal` is `true`) because all workload
  // machine users will already be included in the results. Note that this has
  // no impact when listing by name or CRN. For those calls, internal machine
  // users are always returned.
  bool includeWorkloadMachineUsers = 7;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListMachineUsersResponse {
  repeated MachineUser machineUser = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message DeleteMachineUserRequest {
  // The account id from which to delete the machine user.
  string accountId = 1;
  // The name or crn of the machine user to delete.
  string machineUserNameOrCrn = 2;
  // Whether to delete the machine user immediately (and in rare cases risk
  // orphaning associated resources) or spend more time to fully clean up.
  bool unsafeDelete = 3;
}

message DeleteMachineUserResponse {
  // A list of all the access key CRNs that were deleted for the actor
  repeated string accessKeysDeleted = 1;
  // A list of all group CRNs from which the user were removed.
  repeated string groupsModified = 2;
  // A list of all the roles CRNs that the users were unassigned from.
  repeated string rolesUnassigned = 3;
  // A list of all resource assignments that were removed. Includes the
  // resource role CRNs and the resource that were assigned.
  repeated ResourceAssignment resourceRolesUnassigned = 4;
  // The Crn of the deleted actor.
  string actorCrn = 5;
  // The workload username of the deleted actor.
  string workloadUsername = 6;
}

message WorkloadPasswordPolicyStorage {
  // Account-wide max lifetime, in ms, of actors workload passwords.
  // The magic value 0 indicates that passwords never expire.
  uint64 workloadPasswordMaxLifetime = 1;
  // The min length of a password. Can be any number between 6 and 256.
  // The default minimum password length is 1.
  uint32 minPasswordLength = 2;
  // Whether passwords must include upper case characters. The default is 'false'.
  bool mustIncludeUpperCaseCharacters = 3;
  // Whether passwords must include lower case characters. The default is 'false'.
  bool mustIncludeLowerCaseCharacters = 4;
  // Whether passwords must include numbers. The default is 'false'.
  bool mustIncludeNumbers = 5;
  // Whether passwords must include symbols. The symbols are '#', '&', '*', '$', '%',
  // '@', '^', '.', '_', and '!'. The default is 'false'.
  bool mustIncludeSymbols = 6;
}

// Object used to serialize account metadata that does not require its own
// columns.
message AccountDetails {
  // Contact your administrator message shown to user
  // when user does not have sufficient rights.
  string contactYourAdministratorMessage = 1;
  // List of entitlements associated with an account
  repeated EntitlementGrant entitlement = 2;
  // Whether login using Cloudera SSO is disabled
  bool clouderaSSOLoginDisabled = 3;
  // The global password policy.
  WorkloadPasswordPolicyStorage globalPasswordPolicy = 4;
  // The password policy for machine users. If set, this will be used for enforcing
  // password complexity for machine users instead of the global password policy
  WorkloadPasswordPolicyStorage machineUsersPasswordPolicy = 5;
  // The console authentication policy.
  AuthenticationPolicy authenticationPolicy = 6;
}

// Set Account Messages request object.
message SetAccountMessagesRequest {
  // The account ID the account messages is for.
  string accountId = 3;
  // Deprecated, use accountId above. This will be removed shortly.
  // The account Resource.id the account message is for.
  resources.Id accountIdDeprecated = 1;
  // The account messages to set.
  AccountMessages accountMessages = 2;
}

// Set Account messages response object.
message SetAccountMessagesResponse {
}

// Object used to submit a request for terms acceptance.
message AcceptTermsRequest {
  // Account ID for which the terms are being accepted
  string accountId = 3;
  // Deprecated, use accountId above. This will be removed shortly.
  // Account Resource.id which the terms are being accepted
  resources.Id accountIdDeprecated = 1;
  // The termsName for the terms being accepted
  string termsName = 2;
}

message AcceptTermsResponse {
}

// Object used to submit a request to clear accepted terms.
message ClearAcceptedTermsRequest {
  // Account id which the terms are being cleared
  string accountId = 1;
  // The termsName for the terms being cleared
  string termsName = 2;
}

message ClearAcceptedTermsResponse {
}

// Object used to submit a request to describe a particular set of Terms
message DescribeTermsRequest {
  // Account Id for which the request is being made
  string accountId = 1;
  // The termsName for the terms to be described
  string termsName = 2;
}

// A common enum used to describe whether terms have been accepted or not
enum AcceptanceState {
  // Default value, in case this object has not been explicitly initialized
  UNSET = 0;
  // There IS an AccountTermsAcceptance record for these terms
  NOT_ACCEPTED = 1;
  // There IS NOT an AccountTermsAcceptance record for these terms
  ACCEPTED = 2;
  // A previous version of the terms has been accepted. The new version needs
  // to be accepted.
  NOT_ACCEPTED_UPDATED_TERMS = 3;
  // AccountTermsAcceptance record for these terms has expired. If both
  // NOT_ACCEPTED_UPDATED_TERMS and EXPIRED are valid states, EXPIRED
  // takes the priority.
  EXPIRED = 4;
}

message DescribeTermsResponse {
  // The termsName for these terms
  string termsName = 1;
  // The text of the terms
  string termsText = 2 [(options.FieldExtension.skipLogging) = true];
  // The acceptance state of the terms
  AcceptanceState acceptanceState = 3;
  // The date the terms were accepted, if they have been accepted
  uint64 acceptanceDateMs = 4;
  // The user that accepted the terms, if they have been accepted
  string acceptorCrn = 5;
  // The terms acceptance expiry date in ms from the Java epoch
  // of 1970-01-01T00:00:00Z. If the value is 0, the terms acceptance
  // never expires.
  uint64 expiryDateMs = 6;
}

// Object used to submit a request to list entitlements for an account
message ListEntitlementsRequest {
  // The account ID to query entitlements of.
  string accountId = 4;
  // Deprecated, use accountId above. This will be removed shortly.
  // The account Resource.id to query entitlements of.
  resources.Id accountIdDeprecated = 1;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

// Entitlement which is granted to account or revoked from an account. This
// is the public-facing Entitlement structure.
message Entitlement {
  // Entitlement name
  string entitlementName = 1;
  // Date Entitlement is granted.
  uint64 grantDateMs = 2;
  // Crn of grantor
  string actorGrantorCrn = 3;
}

message ListEntitlementsResponse {
  // The list of entitlements
  repeated Entitlement entitlement = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

// Object used to submit a request to list terms for an account
message ListTermsRequest {
  // The account ID to query terms for.
  string accountId = 4;
  // Deprecated, use accountId above. This will be removed shortly.
  // The account Resource.id to query terms for.
  resources.Id accountIdDeprecated = 1;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message TermsSummary {
  // The termsName for these terms
  string termsName = 1;
  // The acceptance state of the terms
  AcceptanceState acceptanceState = 2;
  // The date the terms were accepted, if they have been accepted
  uint64 acceptanceDateMs = 3;
  // The user that accepted the terms, if they have been accepted
  string acceptorCrn = 4;
  // The terms acceptance expiry date in ms from the Java epoch
  // of 1970-01-01T00:00:00Z. 0 indicates that the terms acceptance
  // never expires.
  uint64 expiryDateMs = 5;
}

message ListTermsResponse {
  // The list of terms
  repeated TermsSummary termsAcceptanceStates = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message SetTermsAcceptanceExpiryRequest {
  // Account Id for which the request is being made
  string accountId = 1;
  // The termsName of the terms for which expiry is being set.
  string termsName = 2;
  // The terms acceptance expiry date in ms from the Java epoch
  // of 1970-01-01T00:00:00Z. 0 indicates that the terms acceptance
  // never expires.
  uint64 expiryDateInMs = 3;
}

message SetTermsAcceptanceExpiryResponse {
}

message CreateGroupRequest {
  // Account Id for which the request is being made
  string accountId = 1;
  // The name of the group being created
  string groupName = 2;
  // Whether group membership is synced when a user logs in. This is only
  // relevant for federated users as we don't get group membership through
  // cloudera-sso. The default is to sync group membership.
  nullable.BoolValue syncMembershipOnUserLogin = 3;
}

message CreateGroupResponse {
  Group group = 1;
}

message DeleteGroupRequest {
  // Account Id for which the request is being made
  string accountId = 1;
  oneof group_oneof {
    // The name or CRN of the group being deleted
    string groupNameOrCrn = 2;
    // The ID of the group being deleted.
    string groupId = 3;
  }
}

message DeleteGroupResponse {
}

message GetGroupRequest {
  // Account Id for which the request is being made.
  string accountId = 1;
  oneof group_oneof {
    // The name or CRN of the group being retrieved.
    string groupNameOrCrn = 2;
    // The ID of the group being retrieved.
    string groupId = 4;
  }
}

message GetGroupResponse {
  Group group = 1;
}

message ListGroupsRequest {
  // Account Id for which the request is being made
  string accountId = 1;
  // The list is optional. The default is to return all groups.
  repeated string groupNameOrCrn = 2;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
}

message ListGroupsResponse {
  repeated Group group = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message UpdateGroupRequest {
  // Account Id for which the request is being made
  string accountId = 1;
  oneof group_oneof {
    // The name or CRN of the group being updated.
    string groupNameOrCrn = 2;
    // The ID of the group being updated.
    string groupId = 4;
  }
  // Whether group membership is synced when a user logs in. This is only
  // relevant for federated users as we don't get group membership through
  // cloudera-sso.
  bool syncMembershipOnUserLogin = 3;
}

message UpdateGroupResponse {
  Group group = 1;
}

message AddMemberToGroupRequest {
  // The member being added to group
  Actor member = 1;
  oneof group_oneof {
    // The group name or CRN to which the user is being added
    string groupNameOrCrn = 2;
    // The group ID to which the user is being added
    string groupId = 3;
  }
}

message AddMemberToGroupResponse {
  string memberCrn = 1;
}

message RemoveMemberFromGroupRequest {
  // The member being removed from group
  Actor member = 1;
  oneof group_oneof {
    // The group name or CRN from which the user is being removed
    string groupNameOrCrn = 2;
    // The group ID from which the user is being removed
    string groupId = 3;
  }
}

message RemoveMemberFromGroupResponse {
  string memberCrn = 1;
}

message ListGroupMembersRequest {
  // Account Id for which the request is being made
  string accountId = 1;
  oneof group_oneof {
    // The group name or CRN
    string groupNameOrCrn = 2;
    // The group ID
    string groupId = 6;
  }
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
  // Whether to list the group memberships of a deleted group. When it is 'true',
  // the request must pass group CRN or group ID. It must ALWAYS be 'false' for public API calls,
  // irrespective of whether the request contains a group name, group CRN or group ID. This flag
  // is only for our internal use such as to support integration tests and check any leaked
  // resources that left to be cleaned up. Therefore, it can ONLY be "true" for internal
  // use-case. It must ALWAYS be "false" for public APIs.
  bool includeDeleted = 5;
}

message ListGroupMembersResponse {
  // The list of members within the group
  repeated string memberCrn = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message ListGroupsForMemberRequest {
  // Actor for which the group membership details is requested
  Actor member = 1;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message ListGroupsForMemberResponse {
  repeated string groupCrn = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message ListWorkloadAdministrationGroupsForMemberRequest {
  // Crn of member for which workload administration groups are requested.
  string memberCrn = 1;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message ListWorkloadAdministrationGroupsForMemberResponse {
  // A list of workload administration group names the actor
  // is a member of.
  repeated string workloadAdministrationGroupName = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

// Information about a group an actor belongs to. Includes information about
// the roles and resource roles assigned to the group.
message GroupMembershipInfo {
  // The group crn.
  string groupCrn = 1;
  // The list of resource role assignments of the group
  repeated ResourceAssignment resourceAssignment = 2;
  // The list of role assignments of the group
  repeated RoleAssignment roleAssignment = 3;
}

message GetAssigneeAuthorizationInformationRequest {
  // Assignee can be a user, machine user or group.
  string assigneeCrn = 1;
}

message GetAssigneeAuthorizationInformationResponse {
  // The list of direct resource role assignments of the assignee
  repeated ResourceAssignment resourceAssignment = 1;
  // The list of direct role assignments of the assignee
  repeated RoleAssignment roleAssignment = 2;
  // For each group the user or machine user belongs to, this list includes a
  // GroupMembershipInfo object. If the assignee is a group this would return
  // an empty list.
  repeated GroupMembershipInfo groupMembershipInfo = 3;
}

// SAML provider attributes used to create a SAML identity provider connector.
message SamlProviderDetails {
  // The SAML provider metadata. This must be a well-formed XML document that
  // conforms to the SAML 2.0 specifications and contains at least one
  // IDPSSODescriptor node and one or more valid certificates that can be used
  // to validate the IdP assertions. The metadata needs to support 'persistent'
  // NameId and
  string metadata = 1;
}

// LDAP connection attributes used to create a LDAP identity provider connector.
message LdapProviderDetails {
  // LDAP server URL.
  // Required. We support only scheme, host and port
  // Any other attribute supplied as part of the URI would be stripped away for security
  // eg. ldaps://ldap.example.org:663
  string url = 1;
  // Admin connection DN.
  // Optional. Default: Anonymous bind when allowed
  // If not provided, or if supplied an empty string would result in anonymous bind when allowed.
  // e.g. uid=myapp,ou=users,dc=example,dc=org
  string bindDn = 2;
  // Optional. Required if bind is not anonymous
  // This value would be stored in Vault KV store on usermanagement/<ConnectorCrn>:bindPassword
  // Password for bindDN.
  string bindPassword = 3 [(options.FieldExtension.sensitive) = true];
  // Property of the LDAP user object to use when binding to verify the password.
  // e.g. name, email
  string userBindProperty = 4;
  // The base DN from which to search for users by username.
  // e.g. ou=users,dc=example,dc=org
  string userSearchBase = 5;
  // LDAP search filter with which to find a user by username
  // Use the literal {{username}} to have the given username interpolated in for the LDAP search.
  // e.g. (uid={{username}})
  string userSearchFilter = 6;
  // The property of user object to use in {{dn}} interpolation of groupSearchFilter.
  string groupDnProperty = 7;
  // The base DN from which to search for groups.
  // If defined, groupSearchFilter must also be defined for the search to work.
  string groupSearchBase = 8;
  // LDAP search filter for groups.
  // Place literal {{dn}} in the filter to have it replaced by the property defined with groupDnProperty of the found user object.
  // {{username}} is also available and will be replaced with the uid of the found user.
  string groupSearchFilter = 9;

  // https://nodejs.org/dist/latest-v12.x/docs/api/tls.html#tls_tls_createsecurecontext_options
  // Optionally override the trusted CA certificates. Default is to trust the well-known CAs configured in system truststore.
  // System truststore is completely replaced when CAs are explicitly specified using this option.
  // The value can be a string or an Array of strings. Any string can contain multiple PEM CAs concatenated together.
  // The peer's certificate must be chainable to a CA trusted by the server for the connection to be authenticated.
  // When using certificates that are not chainable to a well-known CA, the certificate's CA must be explicitly specified
  // as a trusted or the connection will fail to authenticate. If the peer uses a certificate that doesn't match or chain
  // to one of the default CAs configured in system truststore, use this option to provide a CA certificate that the peer's
  // certificate can match or chain to. For self-signed certificates, the certificate is its own CA, and must be provided.
  // For PEM encoded certificates, supported types are "TRUSTED CERTIFICATE", "X509 CERTIFICATE", and "CERTIFICATE".
  // If the user is setup with a referral, we must provide certificates which can verify connection to every server
  repeated string tlsCaCertificates = 10 [(options.FieldExtension.sensitive) = true];

  // Indicates whether a start TLS request should be initiated on connecting to ldap.
  bool startTls = 19;

  // All LDAP servers are slightly different in their own way. Information required to create a UMS user might be stored under
  // a different attribute. Following properties would help in mapping attributes from a given LDAP server.

  // Mapping user's LDAP entry into idpUserId attribute of UMS
  string usernameMappingAttribute = 20;
  // Mapping user's LDAP entry into email attribute of UMS
  string emailMappingAttribute = 21;
  // Mapping user's LDAP entry into firstName attribute of UMS
  string firstNameMappingAttribute = 22;
  // Mapping user's LDAP entry into lastName attribute of UMS
  string lastNameMappingAttribute = 23;
  // Mapping group's LDAP entry into group attribute of UMS
  string groupNameMappingAttribute = 24;
}

// Local connection attributes used to create a local identity provider connector.
// This was created to support first-time user onboarding and scenarios when an account
// ended up getting locked because of a misconfigured/unreachable identity provider
// This should only be used to configure other (real) IdP connectors
message LocalProviderDetails {
  // Username of the only user who can log-in using this identity provider
  // This field must be admin
  string username = 1;
  // Password of this user
  string password = 2 [(options.FieldExtension.sensitive) = true];
  // Email address of this user
  // This is a required field for interactive login. However, we would not ever want to use this
  // address or expect it to be valid.
  string email = 3;
  // This may be an empty string.
  string firstName = 4;
  // This may be an empty string.
  string lastName = 5;
}

message CreateIdentityProviderConnectorRequest {
  // Account id for which external identity provider connector is created.
  string accountId = 1;
  // Identity provider connector name.
  string identityProviderConnectorName = 2;
  oneof providerDetails_oneof {
    // Covers SAML provider attributes.
    SamlProviderDetails samlDetails = 3;
    // Covers LDAP connection attributes
    LdapProviderDetails ldapDetails = 5;
    // Covers Local connection attributes
    LocalProviderDetails localDetails = 6;
  }
  // Whether to sync groups on login or not. This flag is reversed as the default
  // behavior before this flag was introduced was to sync group on login and the
  // default value for protobuf for booleans is 'false'.
  bool skipGroupSyncOnLogin = 4;
  // Whether to enable SCIM on the IDP provider.
  // SCIM is supported for SAML IDP connectors.
  bool enableScim = 7;
}

// Information about a SAML identity provider connector. Certain fields may not
// be set for ListIdentityProviderConnectors, see below for details.
message SamlProviderInfo {
  // The original metadata that was passed to us. This field will not be set for
  // ListIdentityProviderConnector responses.
  string metadata = 1;
  // The certs provided to us in the IdP metadata xml.
  repeated SamlCert certs = 2;
  // The XML SAML metadata we provided to the customer.
  string cdpSpMetadata = 3;
}

// Information about an LDAP identity provider connector. Certain fields may
// be switched for ListIdentityProviderConnectors, see below for details.
message LdapProviderInfo {
  // LDAP server URL.
  // Required. We support only scheme, host and port
  // Any other attribute supplied as part of the URI would be stripped away for security
  // eg. ldaps://ldap.example.org:663
  string url = 1;
  // Admin connection DN.
  // Optional. Default: Anonymous bind when allowed
  // If not provided, or if supplied an empty string would result in anonymous bind when allowed.
  // e.g. uid=myapp,ou=users,dc=example,dc=org
  string bindDn = 2;
  // Optional. Required if bind is not anonymous
  // This value points to the path in Vault KV store where the actual value of bindPassword is stored.
  // It is formatted as path/to/secret/on/vault:key, where `path/to/secret/on/vault` is the path in Vault
  // where the password is stored. This, when using Vault KV store is a key-value map. `key` is the actual
  // key name inside this map.
  // To enable login via LDAP, console auth service should must have required permissions to read this value.
  string bindPasswordRef = 3 [(options.FieldExtension.sensitive) = true];
  // Property of the LDAP user object to use when binding to verify the password.
  // e.g. name, email
  string userBindProperty = 4;
  // The base DN from which to search for users by username.
  // e.g. ou=users,dc=example,dc=org
  string userSearchBase = 5;
  // LDAP search filter with which to find a user by username
  // Use the literal {{username}} to have the given username interpolated in for the LDAP search.
  // e.g. (uid={{username}})
  string userSearchFilter = 6;
  // The property of user object to use in {{dn}} interpolation of groupSearchFilter.
  string groupDnProperty = 7;
  // The base DN from which to search for groups.
  // If defined, groupSearchFilter must also be defined for the search to work.
  string groupSearchBase = 8;
  // LDAP search filter for groups.
  // Place literal {{dn}} in the filter to have it replaced by the property defined with groupDnProperty of the found user object.
  // {{username}} is also available and will be replaced with the uid of the found user.
  string groupSearchFilter = 9;

  // https://nodejs.org/dist/latest-v12.x/docs/api/tls.html#tls_tls_createsecurecontext_options
  // Optionally override the trusted CA certificates. Default is to trust the well-known CAs configured in system truststore.
  // System truststore is completely replaced when CAs are explicitly specified using this option.
  // The value can be a string or an Array of strings. Any string can contain multiple PEM CAs concatenated together.
  // The peer's certificate must be chainable to a CA trusted by the server for the connection to be authenticated.
  // When using certificates that are not chainable to a well-known CA, the certificate's CA must be explicitly specified
  // as a trusted or the connection will fail to authenticate. If the peer uses a certificate that doesn't match or chain
  // to one of the default CAs configured in system truststore, use this option to provide a CA certificate that the peer's
  // certificate can match or chain to. For self-signed certificates, the certificate is its own CA, and must be provided.
  // For PEM encoded certificates, supported types are "TRUSTED CERTIFICATE", "X509 CERTIFICATE", and "CERTIFICATE".
  // If the user is setup with a referral, we must provide certificates which can verify connection to every server
  repeated string tlsCaCertificates = 10 [(options.FieldExtension.sensitive) = true];

  // Indicates whether a start TLS request should be initiated on connecting to ldap.
  bool startTls = 19;

  // All LDAP servers are slightly different in their own way. Information required to create a UMS user might be stored under
  // a different attribute. Following properties would help in mapping attributes from a given LDAP server.

  // Mapping LDAP entry into idpUserId attribute of UMS
  string usernameMappingAttribute = 20;
  // Mapping LDAP entry into email attribute of UMS
  string emailMappingAttribute = 21;
  // Mapping LDAP entry into firstName attribute of UMS
  string firstNameMappingAttribute = 22;
  // Mapping LDAP entry into lastName attribute of UMS
  string lastNameMappingAttribute = 23;
  // Mapping group's LDAP entry into group attribute of UMS
  string groupNameMappingAttribute = 24;
  // Tells whether this LDAP IDP is enabled for use.
  bool enabled = 25;
}

// Local connection attributes used to create a local identity provider connector.
// This was created to support first-time user onboarding and scenarios when an account
// ended up getting locked because of a misconfigured/unreachable identity provider
// This should only be used to configure other (real) IdP connectors
message LocalProviderInfo {
  // Username of the only user who can log-in using this identity provider
  // This field must be admin
  string username = 1;
  // This value points to the path in Vault KV store where the value of user's password hash is stored.
  // It is formatted as path/to/secret/on/vault:key, where `path/to/secret/on/vault` is the path in Vault
  // where the password is stored. This, when using Vault KV store is a key-value map. `key` is the actual
  // key name inside this map.
  // To enable login via Local, console auth service should must have required permissions to read this value.
  string passwordHashRef = 2 [(options.FieldExtension.sensitive) = true];
  // Email address of this user
  // This is a required field for interactive login. However, we would not ever want to use this
  // address or expect it to be valid.
  string email = 3;
  // This may be an empty string.
  string firstName = 4;
  // This may be an empty string.
  string lastName = 5;
}

message IdentityProviderConnector {
  // Name of the identity provider connector.
  string identityProviderConnectorName = 1;
  // The identity provider connector CRN.
  string crn = 2;
  // The creation date in ms from the java epoch of 1970-01-01T00:00:00Z.
  uint64 creationDate = 3;
  oneof providerDetails_oneof {
    // Covers SAML provider attributes.
    SamlProviderInfo samlDetails = 4;
    // Covers LDAP connection attributes
    LdapProviderInfo ldapDetails = 7;
    // Covers Local connection attributes
    LocalProviderInfo localDetails = 8;
  }
  // Identity provider connector id.
  string identityProviderConnectorId = 5;
  // Whether to sync groups on login or not. This flag is reversed as the default
  // behavior before this flag was introduced was to sync group on login and the
  // default value for protobuf for booleans is 'false'.
  bool skipGroupSyncOnLogin = 6;
  // Whether to enable SCIM on the IDP provider.
  // SCIM is supported for SAML IDP connectors.
  bool enableScim = 9;
  // The SCIM machine user CRN. This will exist if SCIM is enabled, or was enabled in the past.
  string scimMachineUserCrn = 10;
}

message IdpNameOrCrnInfo {
  // Account id for which the request is being made.
  string accountId = 1;
  // Names or CRNs of the identity provider connector.
  repeated string nameOrCrns = 2;
}

message CreateIdentityProviderConnectorResponse {
  IdentityProviderConnector identityProviderConnector = 1;
}

message ListIdentityProviderConnectorsRequest {
  reserved 1, 2;
  int32 pageSize = 3;
  paging.PageToken pageToken = 4;
  // Filter list is optional. The default is to return all connectors.
  oneof filter_oneof {
    // IdpNameOrCrnInfo encapsulates accountId and namesOrCrn list. NameOrCrns
    // list can be empty. If nameOrCrns list is set, accountId is required.
    IdpNameOrCrnInfo idpNameOrCrnInfo = 5;
    // Identity provider connector id. This parameter is set only by console
    // auth service to fetch SAML details from back end.
    string idpConnectorId = 6;
  }
}

message ListIdentityProviderConnectorsResponse {
  // List of identity provider connectors.
  repeated IdentityProviderConnector connector = 1;
  // See the pageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message DeleteIdentityProviderConnectorRequest {
  // Account id for which the request is being made.
  string accountId = 1;
  // Name or Crn of the identity provider connector.
  string connectorNameOrCrn = 2;
}

message DeleteIdentityProviderConnectorResponse {
}

// The intended usage for the certificate referred to in a SAML metadata
// xml.
message SamlCertType {
  enum Value {
    UNSET = 0;
    // Used for SAML assertions signing.
    SIGNING = 1;
    // Use for SAML assertions encryption.
    ENCRYPTION = 2;
    // The type was not set in the xml metadata. This means that the certificate
    // can be used for both signing and encryption.
    SIGNING_ENCRYPTION = 3;
  }
}

// Information about a certificate referred in a SAML Idp metadata xml.
// Certificates can be used for signing, assertion encryption, or both.
// This is used for both storage and wire protocol.
message SamlCert {
  // The type of the certificate;
  SamlCertType.Value type = 1;
  // The X.509 PEM encoded public key.
  string cert = 2 [(options.FieldExtension.skipLogging) = true];
}

// The IdP connector details for a SAML typed connector. Used only for
// dynamo db storage
message SamlIdpDetails {
  // The original metadata xml provided to us when the IdP connector was defined.
  string metadataXml = 1 [(options.FieldExtension.skipLogging) = true];
  // The certs provided to us in the IdP metadata xml.
  repeated SamlCert certs = 2;
  // The XML SAML metadata we provided to the customer.
  string cdpSpMetadata = 3;
  // The SAML SP EntityID, it is used by IdP to lookup registered SP.
  // The legacy SP EntityID "urn:cloudera:altus" should be used if this value is empty.
  string cdpSpEntityId = 4;
}

// The IdP connector details for a LDAP typed connector. Used only for
// dynamo db storage
message LdapIdpDetails {
  // LDAP server URL.
  // Required. We support only scheme, host and port
  // Any other attribute supplied as part of the URI would be stripped away for security
  // eg. ldaps://ldap.example.org:663
  string url = 1;
  // Admin connection DN.
  // Optional. Default: Anonymous bind when allowed
  // If not provided, or if supplied an empty string would result in anonymous bind when allowed.
  // e.g. uid=myapp,ou=users,dc=example,dc=org
  string bindDn = 2;
  // Optional. Required if bind is not anonymous
  // This value points to the path in Vault KV store where the actual value of bindPassword is stored.
  // It is formatted as path/to/secret/on/vault:key, where `path/to/secret/on/vault` is the path in Vault
  // where the password is stored. This, when using Vault KV store is a key-value map. `key` is the actual
  // key name inside this map.
  // To enable login via LDAP, console auth service should must have required permissions to read this value.
  string bindPasswordRef = 3 [(options.FieldExtension.sensitive) = true];
  // Property of the LDAP user object to use when binding to verify the password.
  // e.g. name, email
  string userBindProperty = 4;
  // The base DN from which to search for users by username.
  // e.g. ou=users,dc=example,dc=org
  string userSearchBase = 5;
  // LDAP search filter with which to find a user by username
  // Use the literal {{username}} to have the given username interpolated in for the LDAP search.
  // e.g. (uid={{username}})
  string userSearchFilter = 6;
  // The property of user object to use in {{dn}} interpolation of groupSearchFilter.
  string groupDnProperty = 7;
  // The base DN from which to search for groups.
  // If defined, groupSearchFilter must also be defined for the search to work.
  string groupSearchBase = 8;
  // LDAP search filter for groups.
  // Place literal {{dn}} in the filter to have it replaced by the property defined with groupDnProperty of the found user object.
  // {{username}} is also available and will be replaced with the uid of the found user.
  string groupSearchFilter = 9;

  // https://nodejs.org/dist/latest-v12.x/docs/api/tls.html#tls_tls_createsecurecontext_options
  // Optionally override the trusted CA certificates. Default is to trust the well-known CAs configured in system truststore.
  // System truststore is completely replaced when CAs are explicitly specified using this option.
  // The value can be a string or an Array of strings. Any string can contain multiple PEM CAs concatenated together.
  // The peer's certificate must be chainable to a CA trusted by the server for the connection to be authenticated.
  // When using certificates that are not chainable to a well-known CA, the certificate's CA must be explicitly specified
  // as a trusted or the connection will fail to authenticate. If the peer uses a certificate that doesn't match or chain
  // to one of the default CAs configured in system truststore, use this option to provide a CA certificate that the peer's
  // certificate can match or chain to. For self-signed certificates, the certificate is its own CA, and must be provided.
  // For PEM encoded certificates, supported types are "TRUSTED CERTIFICATE", "X509 CERTIFICATE", and "CERTIFICATE".
  // If the user is setup with a referral, we must provide certificates which can verify connection to every server
  repeated string tlsCaCertificates = 10 [(options.FieldExtension.sensitive) = true];

  // Indicates whether a start TLS request should be initiated on connecting to ldap.
  bool startTls = 19;

  // All LDAP servers are slightly different in their own way. Information required to create a UMS user might be stored under
  // a different attribute. Following properties would help in mapping attributes from a given LDAP server.

  // Mapping LDAP entry into idpUserId attribute of UMS
  string usernameMappingAttribute = 20;
  // Mapping LDAP entry into email attribute of UMS
  string emailMappingAttribute = 21;
  // Mapping LDAP entry into firstName attribute of UMS
  string firstNameMappingAttribute = 22;
  // Mapping LDAP entry into lastName attribute of UMS
  string lastNameMappingAttribute = 23;
  // Mapping group's LDAP entry into group attribute of UMS
  string groupNameMappingAttribute = 24;
  // Tells whether this LDAP IDP is enabled for use.
  bool enabled = 25;
}

// Local connection attributes used to create a local identity provider connector.
// This was created to support first-time user onboarding and scenarios when an account
// ended up getting locked because of a misconfigured/unreachable identity provider
// This should only be used to configure other (real) IdP connectors
// Used only for DynamoDB storage
message LocalIdpDetails {
  // Username of the only user who can log-in using this identity provider
  // This field must be admin
  string username = 1;
  // This value points to the path in Vault KV store where the value of user's password hash is stored.
  // It is formatted as path/to/secret/on/vault:key, where `path/to/secret/on/vault` is the path in Vault
  // where the password is stored. This, when using Vault KV store is a key-value map. `key` is the actual
  // key name inside this map.
  // To enable login via Local, console auth service should must have required permissions to read this value.
  string passwordHashRef = 2 [(options.FieldExtension.sensitive) = true];
  // Email address of this user
  // This is a required field for interactive login. However, we would not ever want to use this
  // address or expect it to be valid.
  string email = 3;
  // This may be an empty string.
  string firstName = 4;
  // This may be an empty string.
  string lastName = 5;
}

// An object used to serialize the IdP connector details to the dynamo db table.
message IdpDetails {
  oneof details {
    // The SAML IdP connector details.
    SamlIdpDetails saml = 1;
    // The LDAP IdP connector details.
    LdapIdpDetails ldap = 2;
    // The Local IdP connector details.
    LocalIdpDetails local = 3;
  }
  // The timestamp when the IDP was set as the default identity provider.
  uint64 setAsDefaultDate = 4;
  // Enable SCIM on the IDP.
  bool enableScim = 5;
  // The machine user Crn for performing SCIM operations.
  string scimMachineUserCrn = 6;
}

message DescribeIdentityProviderConnectorRequest {
  // Account ID for which request is being made.
  string accountId = 1;
  // Name or CRN of the identity provider connector.
  string nameOrCrn = 2;
}

message DescribeIdentityProviderConnectorResponse {
  // Identity provider connector.
  IdentityProviderConnector connector = 1;
}

message UpdateIdentityProviderConnectorRequest {
  // Account id for which external identity provider connector is created.
  string accountId = 1;
  // Identity provider connector name.
  string identityProviderConnectorNameOrCrn = 2;
  oneof providerDetails_oneof {
    // Covers SAML provider attributes.
    SamlProviderDetails samlDetails = 3;
    // Covers LDAP connection attributes
    LdapProviderDetails ldapDetails = 5;
    // Covers Local connection attributes
    LocalProviderDetails localDetails = 6;
  }
  // Whether to sync groups on login or not. This flag is reversed as the default
  // behavior before this flag was introduced was to sync group on login and the
  // default value for protobuf for booleans is 'false'.
  nullable.BoolValue skipGroupSyncOnLogin = 4;
  // Whether to enable SCIM on the IDP provider.
  // SCIM is supported for SAML IDP connectors.
  nullable.BoolValue enableScim = 7;
}

message UpdateIdentityProviderConnectorResponse {
  IdentityProviderConnector identityProviderConnector = 1;
}

message SetClouderaSSOLoginEnabledRequest {
  // Account ID for which request is being made.
  string accountId = 1;
  // If 'true' login using Cloudera SSO will be enabled, otherwise it will be
  // disabled.
  bool enableClouderaSSOLogin = 2;
}

message SetClouderaSSOLoginEnabledResponse {
}

message GetIdPMetadataForWorkloadSSORequest {
  // The account ID the workload cluster belongs to and for which SSO is required.
  string accountId = 1;
}

message GetIdPMetadataForWorkloadSSOResponse {
  // The control plane IdP metadata file.
  string metadata = 1;
}

message WorkloadSamlAuthnResponse {
  // Where to send the authn response.
  string destination = 1;
  // The HTTP method to use to send the response. This is one
  // 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST' or
  // 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'
  string binding = 2;
  // A SAML 2.0 signed authn response.
  string authnResponse = 3 [(options.FieldExtension.skipLogging) = true];
  // The relay state, if any, that was passed to us in the original authn
  // request.
  string relayState = 4;
}

message IdpAuthnRequest {
  // Where to send the authn request. This can be either cloudera sso or a
  // customer identity provider.
  string destination = 1;
  // The HTTP method to use to send the request. This is one of
  // 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST' or
  // 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'.
  string binding = 2;
  // A SAML 2.0 authn request. This is unsigned unless the customer's IdP metadata specifies
  // `WantAuthnRequestsSigned="true"`.
  // How we send a signed request is dependent on the `binding`:
  // - HTTP-POST: Send the authnRequest with an embedded signature.
  // - HTTP-Redirect: Send the authnRequest as three query parameters:
  //   - The unsigned authnRequest.
  //   - The signature.
  //   - The signing algorithm.
  // Note: we currently only support signing authn requests over HTTP-POST (that is, the
  // `IDPSSODescriptor` > `SingleSignOnService` `Binding` is HTTP-POST).
  // See CDPCP-3590.
  string authnRequest = 3 [(options.FieldExtension.skipLogging) = true];
}

message ProcessWorkloadSSOAuthnReqRequest {
  // The account ID the workload cluster sent in the URL parameter.
  string accountId = 1;
  // The deflated base64 encoded SAML2.0 payload as was received from the
  // workload cluster.
  string authnRequest = 2 [(options.FieldExtension.skipLogging) = true];
  // The session-token if one was received.
  string sessionToken = 3 [(options.FieldExtension.sensitive) = true];
  // The relay state provided by the workload SP. May be empty.
  string relayState = 4;
}

message ProcessWorkloadSSOAuthnReqResponse {
  oneof payload {
    // a SAML authn response that should be sent to the to the workload cluster.
    WorkloadSamlAuthnResponse workloadResponse = 1;
    // Session token auth request.
    IdpAuthnRequest authnRequest = 2;
  }
}

message SetWorkloadSubdomainRequest {
  // The account ID to set the workload subdomain for.
  string accountId = 1;
  // The workload subdomain. This must be a DNS compatible name.
  string workloadSubdomain = 2;
}

message SetWorkloadSubdomainResponse {
}

message CreateWorkloadMachineUserRequest {
  // The account ID for which the machine user is needed.
  string accountId = 1;
  // The machine user name. This must be unique name for the username in the
  // account. In case a machine-user with this name already exists the UMS will
  // assume that the machine-user the caller wants to use had already been
  // created before and no error will be thrown.
  string machineUserName = 2;
  // A list of resource assignments to use. May be empty.
  repeated ResourceAssignment resourceAssignment = 3;
  // A list of role roles to use. May be empty
  repeated string roleCrn = 4;
  // Whether to generate an access key or not. If missing or set to 'TRUE' an access
  // key will be generated and returned.
  nullable.BoolValue generateAccessKey = 5;
  // Whether to generate a workload password for the machine user. If missing or set to
  // 'FALSE' the workload password will not be set.
  nullable.BoolValue generateWorkloadPassword = 6;
}

message CreateWorkloadMachineUserResponse {
  // The CRN for the machine user created.
  string machineUserCrn = 1;
  // The access key ID and private key are only returned if an access key was requested,
  // which is the default behavior.
  // The access key ID. Since the rpc is idempotent a new key will be generated
  // for each successful call. Old keys are not removed by this call and will
  // only be removed by calling DeleteWorkloadMachineUser.
  string accessKeyId = 2;
  // The private key for the machine user. This is an Ed25519 private key and is
  // 32 bytes encoded in base64 that should be used to sign requests.
  string privateKey = 3 [(options.FieldExtension.sensitive) = true];
  // The machine user details, including its workload username.
  MachineUser machineUser = 4;
  // The workload password that was generated for the machine user. Only populated if
  // setWorkloadPassword was set to 'TRUE'. Note that since we do not keep the workload
  // password anywhere, but just the hash, consecutive calls to CreateWorkloadMachineUser
  // for the same machine user, will override the old generated password.
  // It is the responsibility of the caller to store the password securely.
  string generatedWorkloadPassword = 5 [(options.FieldExtension.sensitive) = true];
}

message DeleteWorkloadMachineUserRequest {
  // The account ID from which to delete the machine user.
  string accountId = 1;
  // The machine user name or CRN to delete.
  string machineUserNameOrCrn = 2;
}

message DeleteWorkloadMachineUserResponse {
}

message GetWorkloadAdministrationGroupNameRequest {
  // The account ID for the workload administration group.
  string accountId = 1;
  // The name of the right associated with this workload administration group.
  string rightName = 2;
  // The resource on which the above right was granted, e.g., the environment CRN.
  // The resource should be a unique, immutable, and stable over time.
  string resource = 3;
}

message GetWorkloadAdministrationGroupNameResponse {
  // The workload administration group name.
  string workloadAdministrationGroupName = 1;
}

message SetWorkloadAdministrationGroupNameRequest {
  reserved 4;
  // The account ID for the workload administration group.
  string accountId = 1;
  // The name of the right associated with this workload administration group.
  string rightName = 2;
  // The resource on which the above right was granted, e.g., the environment CRN.
  // The resource should be a unique, immutable, and stable over time.
  string resource = 3;
}

message SetWorkloadAdministrationGroupNameResponse {
  // The workload administration group name.
  string workloadAdministrationGroupName = 1;
}

message DeleteWorkloadAdministrationGroupNameRequest {
  // The account ID for the workload administration group.
  string accountId = 1;
  // The name of the right associated with this workload administration group.
  string rightName = 2;
  // The resource on which the above right was granted, e.g., the environment CRN.
  // This should be the same resource identifier as the resource identifier used
  // in the SetWorkloadAdministrationGroupName request.
  string resource = 3;
}

message DeleteWorkloadAdministrationGroupNameResponse {
}

message ListWorkloadAdministrationGroupsRequest {
  // The account ID to list the workload administration group names for.
  string accountId = 1;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message WorkloadAdministrationGroup {
  // The workload administration group name.
  string workloadAdministrationGroupName = 1;
  // The name of the right associated with this workload administration group.
  string rightName = 2;
  // The resource on which the above right was granted, e.g., the environment CRN.
  string resource = 3;
}

message ListWorkloadAdministrationGroupsResponse {
  repeated WorkloadAdministrationGroup workloadAdministrationGroup = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

// A representation of a stored kerberos key. This does not exactly reflect the formal
// ASN.1 structure; that seemed gratuitous.
message StoredKerberosKey {
  // The key type
  int32 keyType = 1;
  // The encrypted value as was returned from the AWS kms client
  string encryptedKeyValue = 2 [(options.FieldExtension.sensitive) = true];
  // The salt type
  int32 saltType = 3;
  // The salt value
  string saltValue = 4;
}

// A structure to store SSH public keys in dynamo.
message SshPublicKeyStorage {
  // The key's ID
  string id = 1;
  // The public key. Only populated for DescribeActorSshPublicKeyResponses. This
  // is the same public key that was used in the call to add the public key, i.e.,
  // a public key in RFC4253 XDR format.
  string publicKey = 2 [(options.FieldExtension.skipLogging) = true];
  // The optional description.
  string description = 3;
}

// A namespace for cloud identities. All cloud identities exist within a cloud
// identity domain. At most one cloud identity may be assigned to a given entity
// within a given domain. Some forms of identity domain are generic across all
// cloud providers, while others are modeled on a per-cloud provider basis.
// The following object is used to represent a cloud identity domain in dynamo.
message CloudIdentityDomainStorage {
  oneof domain {
    // An environment CRN serves as the identity domain when we want cloud
    // identity mappings to be scoped to the environment. This is the case,
    // for example, for service principals. This form of identity domain is
    // applicable to all cloud providers, which is why we define it here,
    // rather than in a cloud-specific subtype of CloudIdentityDomain.
    string environmentCrn = 2;
    // Azure-specific cloud identity domain.
    AzureCloudIdentityDomainStorage azureCloudIdentityDomain = 1;
  }
}

// An object that represents the default domain for a given cloud provider.
message DefaultCloudIdentityDomainStorage {
}

// Object used to represent an Azure cloud identity domain in dynamo.
message AzureCloudIdentityDomainStorage {
  oneof azureDomain {
    // A unique identifier for an Azure AD instance.
    string azureAdIdentifier = 1;
    // The default Azure domain.
    DefaultCloudIdentityDomainStorage defaultAzureDomain = 2;
  }
}

// An identifier for a cloud identity that is unique within the enclosing
// domain. The modeling of a cloud identity name is cloud provider-specific.
// The following object is used to represent a cloud identity name in dynamo.
message CloudIdentityNameStorage {
  oneof name {
    AzureCloudIdentityNameStorage azureCloudIdentityName = 1;
  }
}

// Object used to represent an Azure cloud identity name in dynamo.
message AzureCloudIdentityNameStorage {
  // The Azure object ID (OID).
  string objectId = 1;
}

// Object used to represent a cloud identity in dynamo.
message CloudIdentityStorage {
  // Optional. The domain in which the cloud identity exists. If omitted, the
  // default domain for the cloud provider and account is assumed.
  CloudIdentityDomainStorage cloudIdentityDomain = 1;
  // The unique name of the cloud identity within the domain.
  CloudIdentityNameStorage cloudIdentityName = 2;
}

// Object used to store a list of cloud identities in dynamo.
message CloudIdentitiesStorage {
  // A list of assigned cloud identities.
  repeated CloudIdentityStorage cloudIdentities = 1;
}

// This is used to serialize all the Actor dynamoDB related information that is
// not indexed.
message ActorDetails {
  // The cdp workload password hash, encrypted.
  string encryptedPasswordHash = 1 [(options.FieldExtension.sensitive) = true];
  // The salt used to generate the password hash.
  string passwordHashSalt = 6;
  // The password hash expiration date, in ms from the Java epoch of
  // 1970-01-01T00:00:00Z. The value of 0 means that the password hash does
  // not expire.
  uint64 encryptedPasswordHashExpirationDate = 4;
  // A list of kerberos keys for the actor.
  repeated StoredKerberosKey kerberosKeys = 2;
  // A list of ssh public keys for the actor.
  repeated SshPublicKeyStorage sshPublicKeys = 3;
  // The version of the actor's workload credentials. Version numbering begins at
  // zero. The version is incremented whenever any change is persisted to the actor's
  // password hash, password hash expiration, kerberos keys, or ssh public keys.
  int64 workloadCredentialsVersion = 7;
  // Cloud identities assigned to the actor.
  CloudIdentitiesStorage cloudIdentities = 5;
}

// This is used to serialize all the Group dynamoDB related information that is
// not indexed.
message GroupDetails {
  // Cloud identities assigned to the group.
  CloudIdentitiesStorage cloudIdentities = 1;
}

// This is used to serialize all the ServicePrincipal dynamoDB related
// information that is not indexed.
message ServicePrincipalDetails {
  // Cloud identities assigned to the service principal.
  CloudIdentitiesStorage cloudIdentities = 1;
}

message SetActorWorkloadCredentialsRequest {
  // The actor's CRN
  string actorCrn = 1;
  // The CDP workloads password. This password is going to be hashed and the
  // hash is the only thing that is going to be saved, encrypted, in our database.
  string password = 2 [(options.FieldExtension.sensitive) = true];
}

message SetActorWorkloadCredentialsResponse {
}

message ValidateActorWorkloadCredentialsRequest {
  // The actor's CRN
  string actorCrn = 1;
  // The CDP workload password to validate.
  string password = 2 [(options.FieldExtension.sensitive) = true];
}

message ValidateActorWorkloadCredentialsResponse {
}

// Definition of a Kerberos Key used in rpc calls (vs storage)
message ActorKerberosKey {
  // The key type
  int32 keyType = 1;
  // The key value, base64 encoded
  string keyValue = 2 [(options.FieldExtension.sensitive) = true];
  // The salt type
  int32 saltType = 3;
  // The salt value
  string saltValue = 4;
}

message GetActorWorkloadCredentialsRequest {
  // The actor CRN
  string actorCrn = 1;
}

// TODO CDPCP-3033 - migrate this object to use ActorWorkloadCredentials
message GetActorWorkloadCredentialsResponse {
  // The password hash.
  string passwordHash = 1 [(options.FieldExtension.sensitive) = true];
  // The date, in ms from the Java epoch of 1970-01-01T00:00:00Z, when the
  // password hash expires. A value of 0 indicates that the password hash
  // never expires.
  uint64 passwordHashExpirationDate = 3;
  // A list of kerberos keys for the actor.
  repeated ActorKerberosKey kerberosKeys = 2;
  // The workload username for the actor.
  string workloadUsername = 4;
  // A list of Ssh public keys for the actor.
  repeated SshPublicKey sshPublicKey = 5;
  // The version number of the workload credentials. Version numbering begins at zero.
  int64 workloadCredentialsVersion = 6;
}

message GetEventGenerationIdsRequest {
  // The account ID to retrieve the last event generation IDs for.
  string accountId = 1;
}

// Object collecting the event generation ids for some account.
message EventGenerationIds {
  // Generated when a role was assigned or unassigned to a user, machine-user, or
  // a group. Empty string if no such event has occurred since tracking
  // started.
  string lastRoleAssignmentEventId = 1;
  // Generated when a resource role was assigned or unassigned to a user,
  // machine-user, or a group. Empty string if no such event has occurred
  // since tracking started.
  string lastResourceRoleAssignmentEventId = 2;
  // Generated when a member, i.e., a user or a machine-user, was added or
  // removed from a group. Empty string if no such event has occurred
  // since tracking started.
  string lastGroupMembershipChangedEventId = 3;
  // Generated when an actor, i.e., a user or a machine-user, was deleted.
  // Empty string if no such event has occurred since tracking started.
  string lastActorDeletedEventId = 4;
  // Generated when an actor workload credentials change - the actor called
  // set-workload-password. Empty string if no such event has occurred since
  // tracking started.
  string lastActorWorkloadCredentialsChangedEventId = 5;
}

// GetEventGenerationIdsResponse object.
// New event ids should be added to the EventGenerationIds object rather than
// directly to the GetEventGenerationIdsResponse.
// Individual event id fields can be removed after calling code has migrated
// to using the EventGenerationIds object.
// TODO CDPCP-2938 remove redundant fields
message GetEventGenerationIdsResponse {
  // Generated when a role was assigned or unassigned to a user, machine-user, or
  // a group. Empty string if no such event has occurred since tracking
  // started.
  string lastRoleAssignmentEventId = 1;
  // Generated when a resource role was assigned or unassigned to a user,
  // machine-user, or a group. Empty string if no such event has occurred
  // since tracking started.
  string lastResourceRoleAssignmentEventId = 2;
  // Generated when a member, i.e., a user or a machine-user, was added or
  // removed from a group. Empty string if no such event has occurred
  // since tracking started.
  string lastGroupMembershipChangedEventId = 3;
  // Generated when an actor, i.e., a user or a machine-user, was deleted.
  // Empty string if no such event has occurred since tracking started.
  string lastActorDeletedEventId = 4;
  // Generated when an actor workload credentials change - the actor called
  // set-workload-password. Empty string if no such event has occurred since
  // tracking started.
  string lastActorWorkloadCredentialsChangedEventId = 5;
  // An object collecting the event generation ids.
  EventGenerationIds eventGenerationIds = 6;
}

message AddActorSshPublicKeyRequest {
  // The actor's CRN
  string actorCrn = 1;
  // The RSA or ED25519 public SSH key to add. We do not support DSA or ECDSA
  // public keys. The public key should be in an RFC4253 XDR format, e.g.,
  // ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCqyj3P7cfW/D7xUfvITbq7cDmAfPOq6ZRw2jV6Qq3KXipR/zkEmRz1I38mAHrG+ydX4amVOV1KoylkkAkkeufIqFjsT4GyUhjXcXyYiBIn+BstTz7p+JQQ0uR8UDIdVFjXIhl/KEmUtiCnHlS2LIMlm0AnRmkvM0+xLytZGR2okaRkrDnpXiBu1O1HfjDztQTl+PMfpjoZtRjmgQW+C1DXce7b1AtuRHRGDTR39beZGfIEoJjT2q0BZC3j4VYoEZq2DCrsgeaxBffkm67v2qxW4vnd9GiETZkWp/dOlvPpSt2y2j6INCo2h55KYDXBixsjpyj0BXoKBOda0SIl9ye/ sample_public_key
  // as produced, for example, by ssh-keygen.
  string publicKey = 2 [(options.FieldExtension.skipLogging) = true];
  // An optional description for the public key.
  string description = 3 [(options.FieldExtension.skipLogging) = true];
}

message SshPublicKey {
  //  The Ssh public key CRN
  string crn = 1;
  // the ssh public key SHA256 fingerprint. this is identical to the SHA256
  // produced by running the following command on a public key named 'key.pub':
  // ssh-keygen -l -E SHA256 -f /home/user/.ssh/key.pub.
  // Note that ssh-keygen removes any padding bytes from the BASE64 fingerprint
  // encoding (the '=' characters at the end of the fingerprint) and we will
  // do the same.
  string publicKeyFingerprint = 2;
  // An optional description for the public key
  string description = 3 [(options.FieldExtension.skipLogging) = true];
  // The public key. Only populated for DescribeActorSshPublicKeyResponses. This
  // is the same public key that was given used to add it, i.e., a public key
  // in RFC4253 XDR format.
  string publicKey = 4 [(options.FieldExtension.skipLogging) = true];
}

message AddActorSshPublicKeyResponse {
  // The SSH public key information.
  SshPublicKey sshPublicKey = 1;
}

message ListActorSshPublicKeysRequest {
  // The actor's CRN
  string actorCrn = 1;
}

message ListActorSshPublicKeysResponse {
  // A list of public keys for the actor.
  repeated SshPublicKey publicKey = 1;
}

message DescribeActorSshPublicKeyRequest {
  // The actor's CRN
  string actorCrn = 1;
  // The SSH public key CRN or its SHA256 fingerprint.
  string crnOrFingerprint = 2;
}

message DescribeActorSshPublicKeyResponse {
  // The SSH public key information.
  SshPublicKey publicKey = 1;
}

message DeleteActorSshPublicKeyRequest {
  // The actor's CRN
  string actorCrn = 1;
  // The SSH public key CRN or the its SHA256 fingerprint to remove.
  string crnOrFingerprint = 2;
}

message DeleteActorSshPublicKeyResponse {
}

message WorkloadPasswordPolicy {
  // Account-wide max lifetime, in ms, of actors workload passwords.
  // The magic value 0 indicates that passwords never expire.
  uint64 workloadPasswordMaxLifetime = 1;
  // The min length of a password. Can be any number between 6 and 256.
  // The default minimum password length is 1.
  uint32 minPasswordLength = 2;
  // Whether passwords must include upper case characters. The default is 'false'.
  bool mustIncludeUpperCaseCharacters = 3;
  // Whether passwords must include lower case characters. The default is 'false'.
  bool mustIncludeLowerCaseCharacters = 4;
  // Whether passwords must include numbers. The default is 'false'.
  bool mustIncludeNumbers = 5;
  // Whether passwords must include symbols. The symbols are '#', '&', '*', '$', '%',
  // '@', '^', '.', '_', and '!'. The default is 'false'.
  bool mustIncludeSymbols = 6;
}

message SetWorkloadPasswordPolicyRequest {
  // The account ID
  string accountId = 1;
  // The global password policy to set.
  WorkloadPasswordPolicy globalPolicy = 2;
  // The password policy for machine users. If set, this will be used for enforcing
  // password complexity for machine users instead of the global password policy
  WorkloadPasswordPolicy machineUsersPolicy = 3;
}

message SetWorkloadPasswordPolicyResponse {
}

message UnsetWorkloadPasswordPolicyRequest {
  // The account ID
  string accountId = 1;
  // Whether to unset the global password policy.
  bool unsetGlobalPolicy = 2;
  // Whether to unset the machine user policy
  bool unsetMachineUsersPolicy = 3;
}

message UnsetWorkloadPasswordPolicyResponse {
}

message SetAuthenticationPolicyRequest {
  // The account ID.
  string accountId = 1;
  // The authentication policy.
  AuthenticationPolicy authenticationPolicy = 2;
}

message SetAuthenticationPolicyResponse {
}

// A namespace for cloud identities. All cloud identities exist within a cloud
// identity domain. At most one cloud identity may be assigned to a given entity
// within a given domain. Some forms of identity domain are generic across all
// cloud providers, while others are modeled on a per-cloud provider basis.
// The following object is used to represent a cloud identity domain in the
// wire protocol.
message CloudIdentityDomain {
  oneof domain {
    // An environment CRN serves as the identity domain when we want cloud
    // identity mappings to be scoped to the environment. This is the case,
    // for example, for service principals. This form of identity domain is
    // applicable to all cloud providers, which is why we define it here,
    // rather than in a cloud-specific subtype of CloudIdentityDomain.
    string environmentCrn = 2;
    // Azure-specific cloud identity domain.
    AzureCloudIdentityDomain azureCloudIdentityDomain = 1;
  }
}

// An object that represents the default domain for a given cloud provider.
message DefaultCloudIdentityDomain {
}

// Object used to represent an Azure cloud identity domain in the wire protocol.
message AzureCloudIdentityDomain {
  oneof azureDomain {
    // A unique identifier for an Azure AD instance.
    string azureAdIdentifier = 1;
    // The default Azure domain.
    DefaultCloudIdentityDomain defaultAzureDomain = 2;
  }
}

// An identifier for a cloud identity that is unique within the enclosing
// domain. The modeling of a cloud identity name is cloud provider-specific.
// The following object is used to represent a cloud identity name in the
// wire protocol.
message CloudIdentityName {
  oneof name {
    AzureCloudIdentityName azureCloudIdentityName = 1;
  }
}

// Object used to represent an Azure cloud identity name in the wire protocol.
message AzureCloudIdentityName {
  // The Azure object ID (OID).
  string objectId = 1;
}

// Object used to represent a cloud identity in the wire protocol.
message CloudIdentity {
  // Optional. The domain in which the cloud identity exists. If omitted, the
  // default domain for the cloud provider and account is assumed.
  CloudIdentityDomain cloudIdentityDomain = 1;
  // The unique name of the cloud identity within the domain.
  CloudIdentityName cloudIdentityName = 2;
}

message AssignCloudIdentityRequest {
  // The actor or group to which the cloud identity is to be assigned.
  Assignee assignee = 1;
  // The cloud identity to assign.
  CloudIdentity cloudIdentity = 2;
}

message AssignCloudIdentityResponse {
}

message UnassignCloudIdentityRequest {
  // The actor or group from which the cloud identity is to be unassigned.
  Assignee assignee = 1;
  // The domain in which the cloud identity to unassign exists. Since there
  // can be at most one identity assigned to the actor or group within a given
  // domain, this fully identifies the identity to unassign.
  CloudIdentityDomain cloudIdentityDomain = 2;
}

message UnassignCloudIdentityResponse {
}

message AssignServicePrincipalCloudIdentityRequest {
  // The account id in which the service principal exists.
  string accountId = 1;
  // The service principal to which the cloud identity is to be assigned.
  string servicePrincipal = 2;
  // The cloud identity to assign.
  CloudIdentity cloudIdentity = 3;
}

message AssignServicePrincipalCloudIdentityResponse {
}

message UnassignServicePrincipalCloudIdentityRequest {
  // The account id in which the service principal exists.
  string accountId = 1;
  // The service principal from which the cloud identity is to be unassigned.
  string servicePrincipal = 2;
  // The domain in which the cloud identity to unassign exists. Since there can
  // be at most one identity assigned to the service principal within a given
  // domain, this fully identifies the identity to unassign.
  CloudIdentityDomain cloudIdentityDomain = 3;
}

message UnassignServicePrincipalCloudIdentityResponse {
}

message ListServicePrincipalCloudIdentitiesRequest {
  // The account id in which the service principal cloud identity mappings exist.
  string accountId = 1;
  // Optional list of service principals for which mappings should be listed.
  // The default is to return cloud identity mappings for all service principals.
  repeated string servicePrincipal = 2;
  // Optional environment CRN. If provided, the response will contain service
  // principal cloud identity mappings only for the given environment. By default,
  // mappings for all environments are returned.
  string environmentCrn = 3;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 4;
  paging.PageToken pageToken = 5;
}

message ServicePrincipalCloudIdentities {
  // The service principal.
  string servicePrincipal = 1;
  // List of cloud identities for the service principal.
  repeated CloudIdentity cloudIdentities = 2;
}

message ListServicePrincipalCloudIdentitiesResponse {
  // The list of service principal cloud identity mappings.
  repeated ServicePrincipalCloudIdentities servicePrincipalCloudIdentities = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message GetDefaultIdentityProviderConnectorRequest {
  // The account ID of the default identity provider connector.
  string accountId = 1;
}

message GetDefaultIdentityProviderConnectorResponse {
  // The CRN of the identity provider connector used for CDP initiated logins. The CRN is a user defined
  // identity provider or one of the CDP built-ins (like Cloudera SSO).
  string crn = 1;
}

message SetDefaultIdentityProviderConnectorRequest {
  // The account ID of the default identity provider connector.
  string accountId = 1;
  // The name or CRN of the default identity provider connector.
  string identityProviderNameOrCrn = 2;
}

message SetDefaultIdentityProviderConnectorResponse {
}

message GetUserSyncStateModelRequest {
  // The account id.
  string accountId = 1;
  // The rights checks to be performed on each actor. The response model contains
  // actors that pass at least one of these rights checks. The results of the rights
  // checks are included in the response for each included actor.
  repeated RightsCheck rightsCheck = 2;
}

message GetUserSyncStateModelResponse {
  // Event generation ids when the user sync state model is created. The responses are guaranteed
  // to be at least as recent as the event generation ids.
  EventGenerationIds eventGenerationIds = 1;
  // Users and machine users in this account, along with supporting information needed for
  // user sync. Only users and machine users that have passed at least one right check from the
  // request are included.
  repeated UserSyncActor actor = 2;
  // All groups in this account.
  repeated Group group = 3;
  // All workload administration groups in this account.
  repeated WorkloadAdministrationGroup workloadAdministrationGroup = 4;
}

// Actor workload credentials object. This contains fields needed to set
// workload credentials through user sync.
// TODO CDPCP-3033 - migrate GetActorWorkloadCredentialsResponse to use this object
message ActorWorkloadCredentials {
  reserved 4;
  // The password hash.
  string passwordHash = 1 [(options.FieldExtension.sensitive) = true];
  // The date, in ms from the Java epoch of 1970-01-01T00:00:00Z, when the
  // password hash expires. A value of 0 indicates that the password hash
  // never expires.
  uint64 passwordHashExpirationDate = 3;
  // A list of kerberos keys for the actor.
  repeated ActorKerberosKey kerberosKeys = 2;
  // A list of Ssh public keys for the actor.
  repeated SshPublicKey sshPublicKey = 5;
  // The version number of the workload credentials. Version numbering begins at zero.
  int64 workloadCredentialsVersion = 6;
}

message RightsCheckResult {
  // Results of a rights checks, returned in the same order as
  // the right list in the corresponding RightsCheck
  repeated bool hasRight = 1;
}

message UserSyncActor {
  // Information extracted from a User or MachineUser
  UserSyncActorDetails actorDetails = 1;
  // Results of the RightsChecks, returned in the same order as the
  // rightsCheck field of the request.
  repeated RightsCheckResult rightsCheckResult = 2;
  // Groups this actor is a member of, represented as indices into the
  // list of groups in the response.
  repeated int32 groupIndex = 3;
  // Wags this actor is a member of, represented as indices into the
  // list of workload administration groups in the response.
  repeated int32 workloadAdministrationGroupIndex = 4;
  // Credentials.
  ActorWorkloadCredentials credentials = 5;
}

message UserSyncActorDetails {
  // The name user sync will store in the first name field
  string firstName = 1;
  // The name user sync will store in the last name field
  string lastName = 2;
  // The actor's CRN
  string crn = 3;
  // The actor's workload username
  string workloadUsername = 4;
  // The actor's cloud identities
  repeated CloudIdentity cloudIdentity = 5;
  // The state of the actor.
  ActorState.Value state = 6;
}

// Encapsulation of metadata associated with actors in workload clusters.
// This metadata is used by user sync to optimize the updating of workload
// credentials.
message WorkloadUserSyncActorMetadata {
  // sint64 encodes negative numbers more efficiently than int64. This gives
  // us the option of using -1 as an "unknown" version value on the workload
  // side, with compact encoding.
  sint64 workloadCredentialsVersion = 1;
}

message RoleAssignmentRecord {
  // The CRN of an assignee to whom role is assigned.
  string assigneeCrn = 1;
  // The CRN of a role assigned to an assignee.
  string roleCrn = 2;
}

message ListRoleAssignmentsRequest {
  // Account for which to list the resource role assignments
  string accountId = 1;
  // See the PageToken comment in paging.proto on paging usage.
  int32 pageSize = 2;
  paging.PageToken pageToken = 3;
}

message ListRoleAssignmentsResponse {
  // The list of role assignments in an account.
  repeated RoleAssignmentRecord roleAssignment = 1;
  // See the PageToken comment in paging.proto on paging usage.
  paging.PageToken nextPageToken = 2;
}

message GenerateWorkloadAuthTokenRequest {
  // The workload endpoint URL which will receive and validate the auth token.
  // The default URL of "https://{workload name}.{workload subdomain}.cloudera.site" will be used
  // if this value is not set.
  string workloadEndpointUrl = 1;
  // The workload name.
  string workloadName = 2;
}

message GenerateWorkloadAuthTokenResponse {
  // The authentication token
  string token = 1;
  // When the token will expire (in ms from the Java epoch of 1970-01-01T00:00:00Z)
  uint64 expireAt = 2;
}

message GetWorkloadAuthConfigurationRequest {
  string accountId = 1;
}

// Metadata describing the configuration
// This response contains all required and recommended data defined by the OpenId-Connect-Discovery 1.0
// spec [https://openid.net/specs/openid-connect-discovery-1_0.html], for maximum compatibility now and in the future.
message GetWorkloadAuthConfigurationResponse {
  // URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.
  // This MUST be identical to the iss Claim value in ID Tokens issued from this Issuer.
  string issuer = 1;
  // URL of the OP's OAuth 2.0 Authorization Endpoint (Empty)
  string authorizationEndpoint = 2;
  // URL of the OP's OAuth 2.0 Token Endpoint
  string tokenEndpoint = 3;
  // URL of the OP's UserInfo Endpoint (Empty)
  string userInfoEndpoint = 4;
  // URL of the OP's Dynamic Client Registration Endpoint (Empty)
  string registrationEndpoint = 5;
  // JSON Web Key Set document
  // This contains the signing key(s) the RP uses to validate signatures from the OP.
  JsonWebKeySet jwks = 6;
  // An array containing a list of the OAuth 2.0 scope values that this server supports. (Empty)
  repeated string scopesSupported = 7;
  // An array containing a list of the OAuth 2.0 response_type values that this OP supports. (id_token)
  repeated string responseTypesSupported = 8;
  // An array containing a list of the Claim Names of the Claims that this OP MAY be able to supply values for.
  repeated string claimsSupported = 9;
  // array containing a list of the Subject Identifier types that this OP supports. (public)
  repeated string subjectTypesSupported = 10;
  // An array containing a list of the JWS signing algorithms (alg values) supported for the ID Token to encode the Claims in a JWT. (RS256)
  repeated string idTokenSigningAlgValuesSupported = 11;
}

// JWK Set, defined by JSON Web Key (JWK) [https://tools.ietf.org/html/rfc7517]
message JsonWebKeySet {
  // JsonWebKey set.
  repeated JsonWebKey keys = 1;
}

// JSON Web Key, defined by JSON Web Key (JWK) [https://tools.ietf.org/html/rfc7517]
message JsonWebKey {
  // The "kty" (key type) parameter
  string kty = 1;
  // The "use" (public key use) parameter
  string use = 2;
  // The "key_ops" (key operations) parameter
  repeated string key_ops = 3;
  // The "alg" (algorithm) parameter
  string alg = 4;
  // The "kid" (key ID) parameter
  string kid = 5;
  // The "x5u" (X.509 URL) parameter
  string x5u = 6;
  // The "x5c" (X.509 certificate chain) parameter
  repeated string x5c = 7;
  // The "x5t" (X.509 certificate SHA-1 thumbprint) parameter
  string x5t = 8;
  // The "x5t#S256" (X.509 certificate SHA-256 thumbprint) parameter
  string x5t_S256 = 9;
  // RSA key modulus "n"
  string n = 10;
  // RSA key public exponent "e"
  string e = 11;
}

message GenerateControlPlaneSSOAuthnReqRequest {
  // The account id.
  string accountId = 1;
  // The identity provider name or CRN to use to login.
  // The identity provider should be a SAML IdP.
  // This field is optional. Default IdP will be used if the value is not set.
  string identityProviderNameOrCrn = 2;
  // The SAML RelayState.
  string relayState = 3;
}

message GenerateControlPlaneSSOAuthnReqResponse {
  // SAML AuthnRequest to login with IdP.
  IdpAuthnRequest authnRequest = 1;
}

message UpdateUserRequest {
  // The account ID. Required.
  string accountId = 1;
  // The user ID or CRN.  Required.
  string userIdOrCrn = 2;
  // The first name to updated for the user. It can be set to an empty string.
  // If it is set then user's firstName will be updated to its value.
  // If it is not set then user's firstName will not be changed.
  nullable.StringValue firstName = 3;
  // The last name to update for the user. It can be set to an empty string.
  // If it is set then user's lastName will be updated to its value.
  // If it is not set then user's lastName will not be changed.
  nullable.StringValue lastName = 4;
  // The email to update for the user. If it set then it must be non-empty string.
  // If it is set then user's email will be updated to its value.
  // If it is not set then the user's email will not be changed.
  nullable.StringValue email = 5;
  // A idpUserId value to update. It maps to the SAML NameID generated by the 3rd party IdP
  // to uniquely identify user. We must NOT allow updating this field because it maps to
  // `identityProviderUserId ` on our storage layer which builds the partition key (primary key)
  // of the User. It also maps to the "userName" attribute of the SCIM User schema and passed as
  // "userName". If its update value mismatch with the existing value in the storage, then we
  // will throw an exceptions. If it is not set then, it will be ignored.
  nullable.StringValue idpUserId = 6;
  // This is a switch to enable or disable a user.
  // User.state will be set to ActorState.Value.DEACTIVATED if the value is true.
  // User.state will be set to ActorState.Value.ACTIVE if the value is false.
  // If it is not set then the user's state will not be changed.
  nullable.BoolValue isDeactivated = 7;
}

message UpdateUserResponse {
  // The updated user.
  User user = 1;
}
