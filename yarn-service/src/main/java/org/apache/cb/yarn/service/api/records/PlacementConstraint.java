/*
 * YARN Simplified API layer for services
 * Bringing a new service on YARN today is not a simple experience. The APIs of existing frameworks are either too low level (native YARN), require writing new code (for frameworks with programmatic APIs) or writing a complex spec (for declarative frameworks).  This simplified REST API can be used to create and manage the lifecycle of YARN services. In most cases, the application owner will not be forced to make any changes to their applications. This is primarily true if the application is packaged with containerization technologies like Docker.  This document describes the API specifications (aka. YarnFile) for deploying/managing containerized services on YARN. The same JSON spec can be used for both REST API and CLI to manage the services.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package org.apache.cb.yarn.service.api.records;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonProperty;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

/**
 * Placement constraint details.
 */
@ApiModel(description = "Placement constraint details.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-08-08T16:59:40.572+02:00")
public class PlacementConstraint {
    @JsonProperty("name")
    private String name = null;

    @JsonProperty("type")
    private PlacementType type = null;

    @JsonProperty("scope")
    private PlacementScope scope = null;

    @JsonProperty("target_tags")
    private List<String> targetTags = null;

    @JsonProperty("node_attributes")
    private Map<String, List<String>> nodeAttributes = null;

    @JsonProperty("node_partitions")
    private List<String> nodePartitions = null;

    @JsonProperty("min_cardinality")
    private Long minCardinality = null;

    @JsonProperty("max_cardinality")
    private Long maxCardinality = null;

    public PlacementConstraint name(String name) {
        this.name = name;
        return this;
    }

    /**
     * An optional name associated to this constraint.
     *
     * @return name
     **/
    @ApiModelProperty(example = "C1", value = "An optional name associated to this constraint.")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public PlacementConstraint type(PlacementType type) {
        this.type = type;
        return this;
    }

    /**
     * The type of placement.
     *
     * @return type
     **/
    @ApiModelProperty(required = true, value = "The type of placement.")
    public PlacementType getType() {
        return type;
    }

    public void setType(PlacementType type) {
        this.type = type;
    }

    public PlacementConstraint scope(PlacementScope scope) {
        this.scope = scope;
        return this;
    }

    /**
     * The scope of placement.
     *
     * @return scope
     **/
    @ApiModelProperty(required = true, value = "The scope of placement.")
    public PlacementScope getScope() {
        return scope;
    }

    public void setScope(PlacementScope scope) {
        this.scope = scope;
    }

    public PlacementConstraint targetTags(List<String> targetTags) {
        this.targetTags = targetTags;
        return this;
    }

    public PlacementConstraint addTargetTagsItem(String targetTagsItem) {
        if (this.targetTags == null) {
            this.targetTags = new ArrayList<String>();
        }
        this.targetTags.add(targetTagsItem);
        return this;
    }

    /**
     * The name of the components that this component&#39;s placement policy is depending upon are added as target tags. So for affinity say, this component&#39;s containers are requesting to be placed on hosts where containers of the target tag component(s) are running on. Target tags can also contain the name of this component, in which case it implies that for anti-affinity say, no more than one container of this component can be placed on a host. Similarly, for cardinality, it would mean that containers of this component is requesting to be placed on hosts where at least minCardinality but no more than maxCardinality containers of the target tag component(s) are running.
     *
     * @return targetTags
     **/
    @ApiModelProperty(value = "The name of the components that this component's placement policy is depending upon are added as target tags. So for affinity say, this component's containers are requesting to be placed on hosts where containers of the target tag component(s) are running on. Target tags can also contain the name of this component, in which case it implies that for anti-affinity say, no more than one container of this component can be placed on a host. Similarly, for cardinality, it would mean that containers of this component is requesting to be placed on hosts where at least minCardinality but no more than maxCardinality containers of the target tag component(s) are running.")
    public List<String> getTargetTags() {
        return targetTags;
    }

    public void setTargetTags(List<String> targetTags) {
        this.targetTags = targetTags;
    }

    public PlacementConstraint nodeAttributes(Map<String, List<String>> nodeAttributes) {
        this.nodeAttributes = nodeAttributes;
        return this;
    }

    public PlacementConstraint putNodeAttributesItem(String key, List<String> nodeAttributesItem) {
        if (this.nodeAttributes == null) {
            this.nodeAttributes = new HashMap<String, List<String>>();
        }
        this.nodeAttributes.put(key, nodeAttributesItem);
        return this;
    }

    /**
     * Node attributes are a set of key:value(s) pairs associated with nodes.
     *
     * @return nodeAttributes
     **/
    @ApiModelProperty(value = "Node attributes are a set of key:value(s) pairs associated with nodes.")
    public Map<String, List<String>> getNodeAttributes() {
        return nodeAttributes;
    }

    public void setNodeAttributes(Map<String, List<String>> nodeAttributes) {
        this.nodeAttributes = nodeAttributes;
    }

    public PlacementConstraint nodePartitions(List<String> nodePartitions) {
        this.nodePartitions = nodePartitions;
        return this;
    }

    public PlacementConstraint addNodePartitionsItem(String nodePartitionsItem) {
        if (this.nodePartitions == null) {
            this.nodePartitions = new ArrayList<String>();
        }
        this.nodePartitions.add(nodePartitionsItem);
        return this;
    }

    /**
     * Node partitions where the containers of this component can run.
     *
     * @return nodePartitions
     **/
    @ApiModelProperty(value = "Node partitions where the containers of this component can run.")
    public List<String> getNodePartitions() {
        return nodePartitions;
    }

    public void setNodePartitions(List<String> nodePartitions) {
        this.nodePartitions = nodePartitions;
    }

    public PlacementConstraint minCardinality(Long minCardinality) {
        this.minCardinality = minCardinality;
        return this;
    }

    /**
     * When placement type is cardinality, the minimum number of containers of the depending component that a host should have, where containers of this component can be allocated on.
     *
     * @return minCardinality
     **/
    @ApiModelProperty(example = "2", value = "When placement type is cardinality, the minimum number of containers of the depending component that a host should have, where containers of this component can be allocated on.")
    public Long getMinCardinality() {
        return minCardinality;
    }

    public void setMinCardinality(Long minCardinality) {
        this.minCardinality = minCardinality;
    }

    public PlacementConstraint maxCardinality(Long maxCardinality) {
        this.maxCardinality = maxCardinality;
        return this;
    }

    /**
     * When placement type is cardinality, the maximum number of containers of the depending component that a host should have, where containers of this component can be allocated on.
     *
     * @return maxCardinality
     **/
    @ApiModelProperty(example = "3", value = "When placement type is cardinality, the maximum number of containers of the depending component that a host should have, where containers of this component can be allocated on.")
    public Long getMaxCardinality() {
        return maxCardinality;
    }

    public void setMaxCardinality(Long maxCardinality) {
        this.maxCardinality = maxCardinality;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PlacementConstraint placementConstraint = (PlacementConstraint) o;
        return Objects.equals(this.name, placementConstraint.name) &&
                Objects.equals(this.type, placementConstraint.type) &&
                Objects.equals(this.scope, placementConstraint.scope) &&
                Objects.equals(this.targetTags, placementConstraint.targetTags) &&
                Objects.equals(this.nodeAttributes, placementConstraint.nodeAttributes) &&
                Objects.equals(this.nodePartitions, placementConstraint.nodePartitions) &&
                Objects.equals(this.minCardinality, placementConstraint.minCardinality) &&
                Objects.equals(this.maxCardinality, placementConstraint.maxCardinality);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, type, scope, targetTags, nodeAttributes, nodePartitions, minCardinality, maxCardinality);
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class PlacementConstraint {\n");

        sb.append("    name: ").append(toIndentedString(name)).append("\n");
        sb.append("    type: ").append(toIndentedString(type)).append("\n");
        sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
        sb.append("    targetTags: ").append(toIndentedString(targetTags)).append("\n");
        sb.append("    nodeAttributes: ").append(toIndentedString(nodeAttributes)).append("\n");
        sb.append("    nodePartitions: ").append(toIndentedString(nodePartitions)).append("\n");
        sb.append("    minCardinality: ").append(toIndentedString(minCardinality)).append("\n");
        sb.append("    maxCardinality: ").append(toIndentedString(maxCardinality)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}

