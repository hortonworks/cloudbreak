#!/usr/bin/env bash
set -x

TEMPORARY_STORAGE="{{ (salt['pillar.get']('mount_data')[salt['grains.get']('fqdn')])['temporary_storage'] }}"
CLOUD_PLATFORM="{{ (salt['pillar.get']('mount_data')[salt['grains.get']('fqdn')])['cloud_platform'] }}"
PREVIOUS_FSTAB="{{ (salt['pillar.get']('mount_data')[salt['grains.get']('fqdn')])['previous_fstab'] }}"
FS_TYPE=ext4

source /opt/salt/scripts/format-and-mount-common.sh

LOG_FILE=/var/log/mount-disks-after-adding-volumes.log
VERSION="V1.0"

# OUTPUT
#   happy path:
#       exit code: 0
#
#   error:
#       exit code: not 0
#       stderr: a one line info. Details are in the log
format_disks_if_unformatted() {
    local device_name=$1
    local iter=$2
    log $LOG_FILE "format disk arguments: ${device_name}"
    local return_value=0
    log $LOG_FILE "device: ${device_name}"
    BLKID_OUTPUT=$(blkid "$device_name" 2>&1)
    log $LOG_FILE "blkid output: ${BLKID_OUTPUT}"
    if [ -z "$BLKID_OUTPUT" ]; then
        if [[ "$CLOUD_PLATFORM" == "GCP" ]]; then
          device_name=/dev/disk/by-id/google-local-nvme-ssd-${iter}
        fi
        log $LOG_FILE "formatting: ${device_name}"
        $(mkfs -E lazy_itable_init=1 -O uninit_bg -F -t $FS_TYPE ${device_name} >> $LOG_FILE 2>&1)
        if [ ! $? -eq 0 ]; then
        log $LOG_FILE "formatting of device ${device_name} failed"
        return_value=1
        fi
    fi
    return $((return_value))
}

unmount_all_storages() {
  log $LOG_FILE "Starting Global Storage Reset (excluding root and /dbfs)..."

  # Get all block devices
  local all_volumes=$(lsblk_command | grep -v part | grep ^[a-z] | cut -f1 -d' ')
  local root_disk=$(get_root_disk)

  for vol in $all_volumes; do
      local dev_path="/dev/$vol"
      local uuid=$(get_disk_uuid "$dev_path")

      # 1. Protection Guard: Skip root disk
      if [[ "$dev_path" == "$root_disk" ]]; then
          continue
      fi

      # 2. Protection Guard: Skip if mounted at /dbfs
      local current_mount=$(awk -v u="UUID=$uuid" '$1==u {print $2}' /etc/fstab)
      if [[ "$current_mount" == "/dbfs" ]]; then
          log $LOG_FILE "Skipping reset for $vol (Database Volume at /dbfs)"
          continue
      fi

      # 3. Action: Unmount and clean fstab for everything else
      if [[ -n "$current_mount" ]]; then
          log $LOG_FILE "Resetting $vol: Unmounting $current_mount and removing from fstab."
          umount -l "$current_mount" >> $LOG_FILE 2>&1
          sed -i "\|UUID=$uuid|d" /etc/fstab
          sed -i "\|${current_mount}|d" /etc/fstab

          # Clean up the directory so mkdir can recreate it fresh
          if [[ "$current_mount" =~ ^/hadoopfs/ ]]; then
              rmdir "$current_mount" 2>/dev/null
          fi
      fi
  done
}

unmount_storage() {
    local storage_path=$1
    local fs_path=$2
    if umount "${storage_path}" >> $LOG_FILE 2>&1; then
        sed -i -E "${fs_path}" /etc/fstab
    fi
}

mount_instance_store() {
    local counter=$1
    local volume=$2
    local uuid=$(get_disk_uuid "/dev/$volume")
    local mount_point=$(awk -v uuid="UUID=$uuid" '$1 == uuid {print $2}' /etc/fstab)
    if [[ -n "$(nvme list | grep "$volume" | grep "Instance Storage")" && -z "$mount_point" ]]; then
        mount_one "UUID=$uuid /hadoopfs/ephfs${counter} $FS_TYPE defaults,noatime,nofail 0 2"
        return_value=$?
        log $LOG_FILE "result of all mounting: $return_value"
        if [[ $return_value -eq 0 ]]; then
            ((counter++))
        fi
    fi
    echo "$counter"
}

unmount_and_mount_block_store() {
    local counter=$1
    local volume=$2
    local uuid=$(get_disk_uuid "/dev/$volume")
    log $LOG_FILE "mounting volume $volume with uuid ${uuid} to path /hadoopfs/fs${counter}"
    local mount_point=$(awk -v uuid="UUID=$uuid" '$1 == uuid {print $2}' /etc/fstab)
    if [[ -z "$mount_point" ]]; then
        unmount_storage "/hadoopfs/fs${counter}" "/hadoopfs\/fs${counter}/d"
        format_disks_if_unformatted "/dev/$volume" "$counter"
        if [[ -z "$uuid" ]]; then
            uuid=$(get_disk_uuid "/dev/$volume")
        fi
        mount_one "UUID=$uuid /hadoopfs/fs${counter} $FS_TYPE defaults,noatime,nofail 0 2"
        ((counter++))
    else
        log $LOG_FILE "Skipping: UUID ${uuid} is already mounted/configured at ${mount_point}"
    fi
    echo $((counter))
}

get_hadoopfs_dir_counter() {
    ## This method parses /etc/fstab to figure out what is the highest number of disks mounted under fs* and gives back the number to mount the unmounted disks
    local fs_counter=$(awk '$2 ~ /^\/hadoopfs\/fs/ {print $2}' /etc/fstab | sed 's|/hadoopfs/fs||' | sort -n | tail -1)
    echo "${fs_counter:-0}"
}

mount_all_attached_disks_aws() {
      local hadoop_fs_dir_counter
      local hadoop_ephfs_dir_counter
      local return_value=0

      # Check if ephfs already exists in fstab
      local ephfs_already_exists=$(grep "/hadoopfs/ephfs" /etc/fstab)
      log $LOG_FILE ephfs_already_exists: $ephfs_already_exists

      # 1. State-Based Reset
      if [[ -n $(nvme list | grep "Instance Storage") && -z "$ephfs_already_exists" ]]; then
          log $LOG_FILE "Hybrid transition detected: Resetting all non-critical mounts."
          unmount_all_storages
          hadoop_fs_dir_counter=1
          hadoop_ephfs_dir_counter=1
      else
          # Regular run: Just find the next available slot
          hadoop_fs_dir_counter=$(( $(get_hadoopfs_dir_counter) + 1 ))
      fi

      log $LOG_FILE "Starting EBS mounting at counter: $hadoop_fs_dir_counter"

      # 2. Get Disks to Process
      # We use lsblk_command to find all disks.
      # The functions below will check if they are already in fstab or if they need mounting.
      not_mounted_volume_names=$(lsblk_command | grep -v part | grep ^[a-z] | cut -f1 -d' ')
      log $LOG_FILE remaining not mounted volumes: $not_mounted_volume_names
      root_disk=$(get_root_disk)

      for volume in $not_mounted_volume_names; do
          local dev_path="/dev/$volume"
          [[ "$dev_path" == "$root_disk" ]] && continue
          local uuid=$(get_disk_uuid "$dev_path")
          local current_mount=$(awk -v u="UUID=$uuid" '$1==u {print $2}' /etc/fstab)
          [[ "$current_mount" == "/dbfs" ]] && continue
          if not_elastic_block_store $dev_path $LOG_FILE; then
              log $LOG_FILE "Routing Instance Store $volume to ephfs"
              hadoop_ephfs_dir_counter=$(mount_instance_store "$hadoop_ephfs_dir_counter" "$volume")
          elif ! not_elastic_block_store $dev_path $LOG_FILE ; then
              log $LOG_FILE volume $volume is a EBS volume and starting to unmount and mount it
              hadoop_fs_dir_counter=$(unmount_and_mount_block_store "$hadoop_fs_dir_counter" "$volume")
          fi
      done

    return $((return_value))
}

get_unmounted_disks() {
    if [[ -z $(lsblk -I 8,259 -no NAME,MOUNTPOINT,PKNAME) ]]; then
        lsblk -dn | grep -v part | grep ^[a-z] | cut -f1 -d' '
    else
        lsblk -I 8,259 -dno NAME | grep -v -E $(lsblk -I 8,259 -no NAME,MOUNTPOINT,PKNAME | awk '$2 != "" {print $1; if($3!="") print $3}' | grep -oE '[a-zA-Z0-9\-_]+' | sort -u | tr '\n' '|' | sed 's/|$//')
    fi
}

mount_all_attached_disks_azure() {
      local hadoop_fs_dir_counter=$(( $(get_hadoopfs_dir_counter) + 1 ))
      local return_value=0
      local non_ebs_device_id=""
      not_mounted_volume_names=$(get_unmounted_disks)
      log $LOG_FILE remaining not mounted volumes: $not_mounted_volume_names
      if [[ "$TEMPORARY_STORAGE" == "EPHEMERAL_VOLUMES" ]]; then
           non_ebs_device_id="/dev/sdb"
      else
           non_ebs_device_id="/dev/sda"
      fi
      log $LOG_FILE non_ebs_device_id: $non_ebs_device_id
      for volume in $not_mounted_volume_names; do
          local uuid=$(get_disk_uuid "/dev/$volume")
          local current_mount=$(awk -v u="UUID=$uuid" '$1==u {print $2}' /etc/fstab)
          [[ "$current_mount" =~ ^/(dbfs|boot)$ ]] && continue
          if [[ "/dev/$volume" > "$non_ebs_device_id" ]]; then
              hadoop_fs_dir_counter=$(unmount_and_mount_block_store "$hadoop_fs_dir_counter" "$volume")
          else
              log $LOG_FILE volume $volume is not EBS, skipping it
          fi
      done

    return $((return_value))
}

mount_one() {
      local return_value=0
      local fstab_line=$1
      local path=$(echo $fstab_line | cut -d' ' -f2)

      log $LOG_FILE "mounting to path $path, line in fstab: $fstab_line"
      mkdir $path >> $LOG_FILE 2>&1
      echo $fstab_line >> /etc/fstab
      log $LOG_FILE "result of editing fstab: $?"
      mount $path >> $LOG_FILE 2>&1
      if [ ! $? -eq 0 ]; then
        log $LOG_FILE "error mounting device on $path"
        return_value=1
      fi
      log $LOG_FILE "result of mounting $path: $?"
      chmod 1777 $path >> $LOG_FILE 2>&1
      return $((return_value))
}

mount_common() {
    local return_value
    mkdir /hadoopfs
    if [[ "$CLOUD_PLATFORM" == "AZURE" ]]; then
      mount_all_attached_disks_azure
    else
      mount_all_attached_disks_aws
    fi
    return_value=$?
    return $((return_value))
}

save_env_vars_to_log_file() {
    log $LOG_FILE environment variables:
    log $LOG_FILE TEMPORARY_STORAGE=$TEMPORARY_STORAGE
    log $LOG_FILE CLOUD_PLATFORM=$CLOUD_PLATFORM
    log $LOG_FILE PREVIOUS_FSTAB=$PREVIOUS_FSTAB
}

main() {
    log $LOG_FILE "started, version: $VERSION"
    log $LOG_FILE We will calculate the device names and not using the ATTACHED_VOLUME_UUID_LIST which is $ATTACHED_VOLUME_UUID_LIST
    device_name_list=$(get_device_names $LOG_FILE)
    log $LOG_FILE The calculate device name list is $device_name_list
    export ATTACHED_VOLUME_UUID_LIST=$(get_uuid_list $LOG_FILE "$device_name_list") # ephemeral devices' uuid should not be returned
    log $LOG_FILE The calculated ATTACHED_VOLUME_UUID_LIST is $ATTACHED_VOLUME_UUID_LIST

    local attached_volume_uuid_array=($ATTACHED_VOLUME_UUID_LIST)

    save_env_vars_to_log_file
    local script_name="mount-disks-after-adding-volumes"

    mount_common
    return_code=$?
    [[ ! $return_code -eq 0 ]] && exit_with_code $LOG_FILE $return_code "Not all devices were mounted"

    exit_with_code $LOG_FILE 0 "Script $script_name ended"
}

[[ "$0" == "$BASH_SOURCE" ]] && main "$@"